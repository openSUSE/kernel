<?xml version="1.0" encoding="UTF-8"?>
<database xmlns="http://nouveau.freedesktop.org/"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="https://gitlab.freedesktop.org/freedreno/ rules-fd.xsd">
<import file="freedreno_copyright.xml"/>
<import file="adreno/adreno_common.xml"/>
<import file="adreno/adreno_pm4.xml"/>
<import file="adreno/a6xx_enums.xml"/>
<import file="adreno/a7xx_enums.xml"/>
<import file="adreno/a6xx_perfcntrs.xml"/>
<import file="adreno/a7xx_perfcntrs.xml"/>
<import file="adreno/a6xx_descriptors.xml"/>

<!--
Each register that is actually being used by driver should have "usage" defined,
currently there are following usages:
- "cmd" - the register is used outside of renderpass and blits,
		roughly corresponds to registers used in ib1 for Freedreno
- "rp_blit" - the register is used inside renderpass or blits
		(ib2 for Freedreno)

It is expected that register with "cmd" usage may be written into only at
the start of the command buffer (ib1), while "rp_blit" usage indicates that register
is either overwritten by renderpass/blit (ib2) or not used if not overwritten
by a particular renderpass/blit.
-->

<domain name="A6XX" width="32" prefix="variant" varset="chip">
	<bitset name="A6XX_RBBM_INT_0_MASK" inline="no" varset="chip">
		<bitfield name="RBBM_GPU_IDLE" pos="0" type="boolean"/>
		<bitfield name="CP_AHB_ERROR" pos="1" type="boolean"/>
		<bitfield name="CP_IPC_INTR_0" pos="4" type="boolean" variants="A7XX-"/>
		<bitfield name="CP_IPC_INTR_1" pos="5" type="boolean" variants="A7XX-"/>
		<bitfield name="RBBM_ATB_ASYNCFIFO_OVERFLOW" pos="6" type="boolean"/>
		<bitfield name="RBBM_GPC_ERROR" pos="7" type="boolean"/>
		<bitfield name="CP_SW" pos="8" type="boolean"/>
		<bitfield name="CP_HW_ERROR" pos="9" type="boolean"/>
		<bitfield name="CP_CCU_FLUSH_DEPTH_TS" pos="10" type="boolean"/>
		<bitfield name="CP_CCU_FLUSH_COLOR_TS" pos="11" type="boolean"/>
		<bitfield name="CP_CCU_RESOLVE_TS" pos="12" type="boolean"/>
		<bitfield name="CP_IB2" pos="13" type="boolean"/>
		<bitfield name="CP_IB1" pos="14" type="boolean"/>
		<bitfield name="CP_RB" pos="15" type="boolean" variants="A6XX"/>
		<!-- Same as above but different name??: -->
		<bitfield name="PM4CPINTERRUPT" pos="15" type="boolean" variants="A7XX-"/>
		<bitfield name="PM4CPINTERRUPTLPAC" pos="16" type="boolean" variants="A7XX-"/>
		<bitfield name="CP_RB_DONE_TS" pos="17" type="boolean"/>
		<bitfield name="CP_WT_DONE_TS" pos="18" type="boolean"/>
		<bitfield name="CP_CACHE_FLUSH_TS" pos="20" type="boolean"/>
		<bitfield name="CP_CACHE_FLUSH_TS_LPAC" pos="21" type="boolean" variants="A7XX-"/>
		<bitfield name="RBBM_ATB_BUS_OVERFLOW" pos="22" type="boolean"/>
		<bitfield name="RBBM_HANG_DETECT" pos="23" type="boolean"/>
		<bitfield name="UCHE_OOB_ACCESS" pos="24" type="boolean"/>
		<bitfield name="UCHE_TRAP_INTR" pos="25" type="boolean"/>
		<bitfield name="DEBBUS_INTR_0" pos="26" type="boolean"/>
		<bitfield name="DEBBUS_INTR_1" pos="27" type="boolean"/>
		<bitfield name="TSBWRITEERROR" pos="28" type="boolean" variants="A7XX-"/>
		<bitfield name="SWFUSEVIOLATION" pos="29" type="boolean" variants="A7XX-"/>
		<bitfield name="ISDB_CPU_IRQ" pos="30" type="boolean"/>
		<bitfield name="ISDB_UNDER_DEBUG" pos="31" type="boolean"/>
	</bitset>

	<!--
		Note the _LPAC bits probably *actually* first appeared in a660, but the
		_BV bits are new in a7xx
	 -->
	<bitset name="A6XX_CP_INT" varset="chip">
		<bitfield name="CP_OPCODE_ERROR" pos="0" type="boolean"/>
		<bitfield name="CP_UCODE_ERROR" pos="1" type="boolean"/>
		<bitfield name="CP_HW_FAULT_ERROR" pos="2" type="boolean"/>
		<bitfield name="CP_REGISTER_PROTECTION_ERROR" pos="4" type="boolean"/>
		<bitfield name="CP_AHB_ERROR" pos="5" type="boolean"/>
		<bitfield name="CP_VSD_PARITY_ERROR" pos="6" type="boolean"/>
		<bitfield name="CP_ILLEGAL_INSTR_ERROR" pos="7" type="boolean"/>
		<bitfield name="CP_OPCODE_ERROR_LPAC" pos="8" type="boolean" variants="A7XX-"/>
		<bitfield name="CP_UCODE_ERROR_LPAC" pos="9" type="boolean" variants="A7XX-"/>
		<bitfield name="CP_HW_FAULT_ERROR_LPAC" pos="10" type="boolean" variants="A7XX-"/>
		<bitfield name="CP_REGISTER_PROTECTION_ERROR_LPAC" pos="11" type="boolean" variants="A7XX-"/>
		<bitfield name="CP_ILLEGAL_INSTR_ERROR_LPAC" pos="12" type="boolean" variants="A7XX-"/>
		<bitfield name="CP_OPCODE_ERROR_BV" pos="13" type="boolean" variants="A7XX-"/>
		<bitfield name="CP_UCODE_ERROR_BV" pos="14" type="boolean" variants="A7XX-"/>
		<bitfield name="CP_HW_FAULT_ERROR_BV" pos="15" type="boolean" variants="A7XX-"/>
		<bitfield name="CP_REGISTER_PROTECTION_ERROR_BV" pos="16" type="boolean" variants="A7XX-"/>
		<bitfield name="CP_ILLEGAL_INSTR_ERROR_BV" pos="17" type="boolean" variants="A7XX-"/>
	</bitset>

	<reg64 offset="0x0800" name="CP_RB_BASE"/>
	<reg32 offset="0x0802" name="CP_RB_CNTL"/>
	<reg64 offset="0x0804" name="CP_RB_RPTR_ADDR"/>
	<reg32 offset="0x0806" name="CP_RB_RPTR"/>
	<reg32 offset="0x0807" name="CP_RB_WPTR"/>
	<reg32 offset="0x0808" name="CP_SQE_CNTL"/>
	<reg32 offset="0x0812" name="CP_CP2GMU_STATUS">
		<bitfield name="IFPC" pos="0" type="boolean"/>
	</reg32>
	<reg32 offset="0x0821" name="CP_HW_FAULT"/>
	<reg32 offset="0x0823" name="CP_INTERRUPT_STATUS" type="A6XX_CP_INT"/>
	<reg32 offset="0x0824" name="CP_PROTECT_STATUS"/>
	<reg32 offset="0x0825" name="CP_STATUS_1"/>
	<reg64 offset="0x0830" name="CP_SQE_INSTR_BASE"/>
	<reg32 offset="0x0840" name="CP_MISC_CNTL"/>
	<reg32 offset="0x0844" name="CP_APRIV_CNTL">
		<!-- Crashdumper writes -->
		<bitfield pos="6" name="CDWRITE" type="boolean"/>
		<!-- Crashdumper reads -->
		<bitfield pos="5" name="CDREAD" type="boolean"/>

		<!-- 4 is unknown -->

		<!-- RPTR shadow writes -->
		<bitfield pos="3" name="RBRPWB" type="boolean"/>
		<!-- Memory accesses from PM4 packets in the ringbuffer -->
		<bitfield pos="2" name="RBPRIVLEVEL" type="boolean"/>
		<!-- Ringbuffer reads -->
		<bitfield pos="1" name="RBFETCH" type="boolean"/>
		<!-- Instruction cache fetches -->
		<bitfield pos="0" name="ICACHE" type="boolean"/>
	</reg32>
	<!-- Preemptions taking longer than this threshold increment PERF_CP_LONG_PREEMPTIONS: -->
	<reg32 offset="0x08C0" name="CP_PREEMPT_THRESHOLD"/>
	<!-- all the threshold values seem to be in units of quad-dwords: -->
	<reg32 offset="0x08C1" name="CP_ROQ_THRESHOLDS_1">
		<doc>
			b0..7 identifies where MRB data starts (and RB data ends)
			b8.15 identifies where VSD data starts (and MRB data ends)
			b16..23 identifies where IB1 data starts (and RB data ends)
			b24..31 identifies where IB2 data starts (and IB1 data ends)
		</doc>
		<bitfield name="MRB_START" low="0" high="7" shr="2"/>
		<bitfield name="VSD_START" low="8" high="15" shr="2"/>
		<bitfield name="IB1_START" low="16" high="23" shr="2"/>
		<bitfield name="IB2_START" low="24" high="31" shr="2"/>
	</reg32>
	<reg32 offset="0x08C2" name="CP_ROQ_THRESHOLDS_2">
		<doc>
			low bits identify where CP_SET_DRAW_STATE stateobj
			processing starts (and IB2 data ends). I'm guessing
			b8 is part of this since (from downstream kgsl):

				/* ROQ sizes are twice as big on a640/a680 than on a630 */
				if (adreno_is_a640(adreno_dev) || adreno_is_a680(adreno_dev)) {
					kgsl_regwrite(device, A6XX_CP_ROQ_THRESHOLDS_2, 0x02000140);
					kgsl_regwrite(device, A6XX_CP_ROQ_THRESHOLDS_1, 0x8040362C);
				} ...
		</doc>
		<bitfield name="SDS_START" low="0" high="8" shr="2"/>
		<!-- total ROQ size: -->
		<bitfield name="ROQ_SIZE" low="16" high="31" shr="2"/>
	</reg32>
	<reg32 offset="0x08C3" name="CP_MEM_POOL_SIZE"/>
	<reg32 offset="0x0841" name="CP_CHICKEN_DBG"/>
	<reg32 offset="0x0842" name="CP_ADDR_MODE_CNTL" type="a5xx_address_mode"/>
	<reg32 offset="0x0843" name="CP_DBG_ECO_CNTL"/>
	<reg32 offset="0x084F" name="CP_PROTECT_CNTL">
		<bitfield pos="3" name="LAST_SPAN_INF_RANGE" type="boolean"/>
		<bitfield pos="1" name="ACCESS_FAULT_ON_VIOL_EN" type="boolean"/>
		<bitfield pos="0" name="ACCESS_PROT_EN" type="boolean"/>
	</reg32>

	<array offset="0x0883" name="CP_SCRATCH" stride="1" length="8">
		<reg32 offset="0x0" name="REG" type="uint"/>
	</array>
	<array offset="0x0850" name="CP_PROTECT" stride="1" length="32">
		<reg32 offset="0x0" name="REG" type="a6x_cp_protect"/>
	</array>

	<reg32 offset="0x08A0" name="CP_CONTEXT_SWITCH_CNTL">
		<bitfield name="STOP" pos="0" type="boolean"/>
		<bitfield name="LEVEL" low="6" high="7"/>
		<bitfield name="USES_GMEM" pos="8" type="boolean"/>
		<bitfield name="SKIP_SAVE_RESTORE" pos="9" type="boolean"/>
	</reg32>
	<reg64 offset="0x08A1" name="CP_CONTEXT_SWITCH_SMMU_INFO"/>
	<reg64 offset="0x08A3" name="CP_CONTEXT_SWITCH_PRIV_NON_SECURE_RESTORE_ADDR"/>
	<reg64 offset="0x08A5" name="CP_CONTEXT_SWITCH_PRIV_SECURE_RESTORE_ADDR"/>
	<reg64 offset="0x08A7" name="CP_CONTEXT_SWITCH_NON_PRIV_RESTORE_ADDR"/>
	<reg32 offset="0x08ab" name="CP_CONTEXT_SWITCH_LEVEL_STATUS" variants="A7XX-"/>
	<array offset="0x08D0" name="CP_PERFCTR_CP_SEL" stride="1" length="14"/>
	<array offset="0x08e0" name="CP_BV_PERFCTR_CP_SEL" stride="1" length="7" variants="A7XX-"/>
	<reg64 offset="0x0900" name="CP_CRASH_DUMP_SCRIPT_BASE"/>
	<reg32 offset="0x0902" name="CP_CRASH_DUMP_CNTL"/>
	<reg32 offset="0x0903" name="CP_CRASH_DUMP_STATUS"/>
	<reg32 offset="0x0908" name="CP_SQE_STAT_ADDR"/>
	<reg32 offset="0x0909" name="CP_SQE_STAT_DATA"/>
	<reg32 offset="0x090A" name="CP_DRAW_STATE_ADDR"/>
	<reg32 offset="0x090B" name="CP_DRAW_STATE_DATA"/>
	<reg32 offset="0x090C" name="CP_ROQ_DBG_ADDR"/>
	<reg32 offset="0x090D" name="CP_ROQ_DBG_DATA"/>
	<reg32 offset="0x090E" name="CP_MEM_POOL_DBG_ADDR"/>
	<reg32 offset="0x090F" name="CP_MEM_POOL_DBG_DATA"/>
	<reg32 offset="0x0910" name="CP_SQE_UCODE_DBG_ADDR"/>
	<reg32 offset="0x0911" name="CP_SQE_UCODE_DBG_DATA"/>
	<reg64 offset="0x0928" name="CP_IB1_BASE"/>
	<reg32 offset="0x092A" name="CP_IB1_REM_SIZE"/>
	<reg64 offset="0x092B" name="CP_IB2_BASE"/>
	<reg32 offset="0x092D" name="CP_IB2_REM_SIZE"/>
	<!-- SDS == CP_SET_DRAW_STATE: -->
	<reg64 offset="0x092e" name="CP_SDS_BASE"/>
	<reg32 offset="0x0930" name="CP_SDS_REM_SIZE"/>
	<!-- MRB == MEM_READ_ADDR/$addr in SQE firmware -->
	<reg64 offset="0x0931" name="CP_MRB_BASE"/>
	<reg32 offset="0x0933" name="CP_MRB_REM_SIZE"/>
	<!--
	VSD == Visibility Stream Decode
	This is used by CP to read the draw stream and skip empty draws
	-->
	<reg64 offset="0x0934" name="CP_VSD_BASE"/>

	<bitset name="a6xx_roq_status" inline="yes">
		<bitfield name="RPTR" low="0" high="9"/>
		<bitfield name="WPTR" low="16" high="25"/>
	</bitset>
	<reg32 offset="0x0939" name="CP_ROQ_RB_STATUS" type="a6xx_roq_status"/>
	<reg32 offset="0x093a" name="CP_ROQ_IB1_STATUS" type="a6xx_roq_status"/>
	<reg32 offset="0x093b" name="CP_ROQ_IB2_STATUS" type="a6xx_roq_status"/>
	<reg32 offset="0x093c" name="CP_ROQ_SDS_STATUS" type="a6xx_roq_status"/>
	<reg32 offset="0x093d" name="CP_ROQ_MRB_STATUS" type="a6xx_roq_status"/>
	<reg32 offset="0x093e" name="CP_ROQ_VSD_STATUS" type="a6xx_roq_status"/>

	<reg32 offset="0x0943" name="CP_IB1_INIT_SIZE"/>
	<reg32 offset="0x0944" name="CP_IB2_INIT_SIZE"/>
	<reg32 offset="0x0945" name="CP_SDS_INIT_SIZE"/>
	<reg32 offset="0x0946" name="CP_MRB_INIT_SIZE"/>
	<reg32 offset="0x0947" name="CP_VSD_INIT_SIZE"/>

	<reg32 offset="0x0948" name="CP_ROQ_AVAIL_RB">
		<doc>number of remaining dwords incl current dword being consumed?</doc>
		<bitfield name="REM" low="16" high="31"/>
	</reg32>
	<reg32 offset="0x0949" name="CP_ROQ_AVAIL_IB1">
		<doc>number of remaining dwords incl current dword being consumed?</doc>
		<bitfield name="REM" low="16" high="31"/>
	</reg32>
	<reg32 offset="0x094a" name="CP_ROQ_AVAIL_IB2">
		<doc>number of remaining dwords incl current dword being consumed?</doc>
		<bitfield name="REM" low="16" high="31"/>
	</reg32>
	<reg32 offset="0x094b" name="CP_ROQ_AVAIL_SDS">
		<doc>number of remaining dwords incl current dword being consumed?</doc>
		<bitfield name="REM" low="16" high="31"/>
	</reg32>
	<reg32 offset="0x094c" name="CP_ROQ_AVAIL_MRB">
		<doc>number of dwords that have already been read but haven't been consumed by $addr</doc>
		<bitfield name="REM" low="16" high="31"/>
	</reg32>
	<reg32 offset="0x094d" name="CP_ROQ_AVAIL_VSD">
		<doc>number of remaining dwords incl current dword being consumed?</doc>
		<bitfield name="REM" low="16" high="31"/>
	</reg32>

	<bitset name="a7xx_aperture_cntl" inline="yes">
		<bitfield name="PIPE" low="12" high="13" type="a7xx_pipe"/>
		<bitfield name="CLUSTER" low="8" high="10" type="a7xx_cluster"/>
		<bitfield name="CONTEXT" low="4" high="5"/>
	</bitset>
	<reg64 offset="0x0980" name="CP_ALWAYS_ON_COUNTER"/>
	<reg32 offset="0x098D" name="CP_AHB_CNTL"/>
	<reg32 offset="0x0A00" name="CP_APERTURE_CNTL_HOST" variants="A6XX"/>
	<reg32 offset="0x0A00" name="CP_APERTURE_CNTL_HOST" type="a7xx_aperture_cntl" variants="A7XX-"/>
	<reg32 offset="0x0A01" name="CP_APERTURE_CNTL_SQE" variants="A6XX"/>
	<reg32 offset="0x0A03" name="CP_APERTURE_CNTL_CD" variants="A6XX"/>
	<reg32 offset="0x0A03" name="CP_APERTURE_CNTL_CD" type="a7xx_aperture_cntl" variants="A7XX-"/>

	<reg32 offset="0x0a61" name="CP_BV_PROTECT_STATUS" variants="A7XX-"/>
	<reg32 offset="0x0a64" name="CP_BV_HW_FAULT" variants="A7XX-"/>
	<reg32 offset="0x0a81" name="CP_BV_DRAW_STATE_ADDR" variants="A7XX-"/>
	<reg32 offset="0x0a82" name="CP_BV_DRAW_STATE_DATA" variants="A7XX-"/>
	<reg32 offset="0x0a83" name="CP_BV_ROQ_DBG_ADDR" variants="A7XX-"/>
	<reg32 offset="0x0a84" name="CP_BV_ROQ_DBG_DATA" variants="A7XX-"/>
	<reg32 offset="0x0a85" name="CP_BV_SQE_UCODE_DBG_ADDR" variants="A7XX-"/>
	<reg32 offset="0x0a86" name="CP_BV_SQE_UCODE_DBG_DATA" variants="A7XX-"/>
	<reg32 offset="0x0a87" name="CP_BV_SQE_STAT_ADDR" variants="A7XX-"/>
	<reg32 offset="0x0a88" name="CP_BV_SQE_STAT_DATA" variants="A7XX-"/>
	<reg32 offset="0x0a96" name="CP_BV_MEM_POOL_DBG_ADDR" variants="A7XX-"/>
	<reg32 offset="0x0a97" name="CP_BV_MEM_POOL_DBG_DATA" variants="A7XX-"/>
	<reg64 offset="0x0a98" name="CP_BV_RB_RPTR_ADDR" variants="A7XX-"/>

	<reg32 offset="0x0a9a" name="CP_RESOURCE_TABLE_DBG_ADDR" variants="A7XX-"/>
	<reg32 offset="0x0a9b" name="CP_RESOURCE_TABLE_DBG_DATA" variants="A7XX-"/>
	<reg32 offset="0x0ad0" name="CP_BV_APRIV_CNTL" variants="A7XX-"/>
	<reg32 offset="0x0ada" name="CP_BV_CHICKEN_DBG" variants="A7XX-"/>

	<reg32 offset="0x0b0a" name="CP_LPAC_DRAW_STATE_ADDR" variants="A7XX-"/>
	<reg32 offset="0x0b0b" name="CP_LPAC_DRAW_STATE_DATA" variants="A7XX-"/>
	<reg32 offset="0x0b0c" name="CP_LPAC_ROQ_DBG_ADDR" variants="A7XX-"/>
	<reg32 offset="0x0b27" name="CP_SQE_AC_UCODE_DBG_ADDR" variants="A7XX-"/>
	<reg32 offset="0x0b28" name="CP_SQE_AC_UCODE_DBG_DATA" variants="A7XX-"/>
	<reg32 offset="0x0b29" name="CP_SQE_AC_STAT_ADDR" variants="A7XX-"/>
	<reg32 offset="0x0b2a" name="CP_SQE_AC_STAT_DATA" variants="A7XX-"/>

	<reg32 offset="0x0b31" name="CP_LPAC_APRIV_CNTL" variants="A7XX-"/>
	<reg32 offset="0x0B34" name="CP_LPAC_PROG_FIFO_SIZE"/>
	<reg32 offset="0x0b35" name="CP_LPAC_ROQ_DBG_DATA" variants="A7XX-"/>
	<reg32 offset="0x0b36" name="CP_LPAC_FIFO_DBG_DATA" variants="A7XX-"/>
	<reg32 offset="0x0b40" name="CP_LPAC_FIFO_DBG_ADDR" variants="A7XX-"/>
	<reg32 offset="0x0b81" name="CP_LPAC_SQE_CNTL"/>
	<reg64 offset="0x0b82" name="CP_LPAC_SQE_INSTR_BASE"/>

	<reg64 offset="0x0b70" name="CP_AQE_INSTR_BASE_0" variants="A7XX-"/>
	<reg64 offset="0x0b72" name="CP_AQE_INSTR_BASE_1" variants="A7XX-"/>
	<reg32 offset="0x0b78" name="CP_AQE_APRIV_CNTL" variants="A7XX-"/>

	<reg32 offset="0x0ba8" name="CP_AQE_ROQ_DBG_ADDR_0" variants="A7XX-"/>
	<reg32 offset="0x0ba9" name="CP_AQE_ROQ_DBG_ADDR_1" variants="A7XX-"/>
	<reg32 offset="0x0bac" name="CP_AQE_ROQ_DBG_DATA_0" variants="A7XX-"/>
	<reg32 offset="0x0bad" name="CP_AQE_ROQ_DBG_DATA_1" variants="A7XX-"/>
	<reg32 offset="0x0bb0" name="CP_AQE_UCODE_DBG_ADDR_0" variants="A7XX-"/>
	<reg32 offset="0x0bb1" name="CP_AQE_UCODE_DBG_ADDR_1" variants="A7XX-"/>
	<reg32 offset="0x0bb4" name="CP_AQE_UCODE_DBG_DATA_0" variants="A7XX-"/>
	<reg32 offset="0x0bb5" name="CP_AQE_UCODE_DBG_DATA_1" variants="A7XX-"/>
	<reg32 offset="0x0bb8" name="CP_AQE_STAT_ADDR_0" variants="A7XX-"/>
	<reg32 offset="0x0bb9" name="CP_AQE_STAT_ADDR_1" variants="A7XX-"/>
	<reg32 offset="0x0bbc" name="CP_AQE_STAT_DATA_0" variants="A7XX-"/>
	<reg32 offset="0x0bbd" name="CP_AQE_STAT_DATA_1" variants="A7XX-"/>

	<reg32 offset="0x0C01" name="VSC_ADDR_MODE_CNTL" type="a5xx_address_mode"/>
	<reg32 offset="0x0018" name="RBBM_GPR0_CNTL"/>
	<reg32 offset="0x0201" name="RBBM_INT_0_STATUS" type="A6XX_RBBM_INT_0_MASK"/>
	<reg32 offset="0x0210" name="RBBM_STATUS">
		<bitfield pos="23" name="GPU_BUSY_IGN_AHB" type="boolean"/>
		<bitfield pos="22" name="GPU_BUSY_IGN_AHB_CP" type="boolean"/>
		<bitfield pos="21" name="HLSQ_BUSY" type="boolean"/>
		<bitfield pos="20" name="VSC_BUSY" type="boolean"/>
		<bitfield pos="19" name="TPL1_BUSY" type="boolean"/>
		<bitfield pos="18" name="SP_BUSY" type="boolean"/>
		<bitfield pos="17" name="UCHE_BUSY" type="boolean"/>
		<bitfield pos="16" name="VPC_BUSY" type="boolean"/>
		<bitfield pos="15" name="VFD_BUSY" type="boolean"/>
		<bitfield pos="14" name="TESS_BUSY" type="boolean"/>
		<bitfield pos="13" name="PC_VSD_BUSY" type="boolean"/>
		<bitfield pos="12" name="PC_DCALL_BUSY" type="boolean"/>
		<bitfield pos="11" name="COM_DCOM_BUSY" type="boolean"/>
		<bitfield pos="10" name="LRZ_BUSY" type="boolean"/>
		<bitfield pos="9"  name="A2D_BUSY" type="boolean"/>
		<bitfield pos="8"  name="CCU_BUSY" type="boolean"/>
		<bitfield pos="7"  name="RB_BUSY" type="boolean"/>
		<bitfield pos="6"  name="RAS_BUSY" type="boolean"/>
		<bitfield pos="5"  name="TSE_BUSY" type="boolean"/>
		<bitfield pos="4"  name="VBIF_BUSY" type="boolean"/>
		<bitfield pos="3"  name="GFX_DBGC_BUSY" type="boolean"/>
		<bitfield pos="2"  name="CP_BUSY" type="boolean"/>
		<bitfield pos="1"  name="CP_AHB_BUSY_CP_MASTER" type="boolean"/>
		<bitfield pos="0"  name="CP_AHB_BUSY_CX_MASTER" type="boolean"/>
	</reg32>
	<reg32 offset="0x0211" name="RBBM_STATUS1"/>
	<reg32 offset="0x0212" name="RBBM_STATUS2"/>
	<reg32 offset="0x0213" name="RBBM_STATUS3">
		<bitfield pos="24" name="SMMU_STALLED_ON_FAULT" type="boolean"/>
	</reg32>
	<reg32 offset="0x0215" name="RBBM_VBIF_GX_RESET_STATUS"/>

	<reg32 offset="0x0260" name="RBBM_CLOCK_MODE_CP" variants="A7XX-"/>
	<reg32 offset="0x0284" name="RBBM_CLOCK_MODE_BV_LRZ" variants="A7XX-"/>
	<reg32 offset="0x0285" name="RBBM_CLOCK_MODE_BV_GRAS" variants="A7XX-"/>
	<reg32 offset="0x0286" name="RBBM_CLOCK_MODE2_GRAS" variants="A7XX-"/>
	<reg32 offset="0x0287" name="RBBM_CLOCK_MODE_BV_VFD" variants="A7XX-"/>
	<reg32 offset="0x0288" name="RBBM_CLOCK_MODE_BV_GPC" variants="A7XX-"/>

	<reg32 offset="0x02c0" name="RBBM_SW_FUSE_INT_STATUS" variants="A7XX-"/>
	<reg32 offset="0x02c1" name="RBBM_SW_FUSE_INT_MASK" variants="A7XX-"/>

	<array offset="0x0400" name="RBBM_PERFCTR_CP" stride="2" length="14" variants="A6XX"/>
	<array offset="0x041c" name="RBBM_PERFCTR_RBBM" stride="2" length="4" variants="A6XX"/>
	<array offset="0x0424" name="RBBM_PERFCTR_PC" stride="2" length="8" variants="A6XX"/>
	<array offset="0x0434" name="RBBM_PERFCTR_VFD" stride="2" length="8" variants="A6XX"/>
	<array offset="0x0444" name="RBBM_PERFCTR_HLSQ" stride="2" length="6" variants="A6XX"/>
	<array offset="0x0450" name="RBBM_PERFCTR_VPC" stride="2" length="6" variants="A6XX"/>
	<array offset="0x045c" name="RBBM_PERFCTR_CCU" stride="2" length="5" variants="A6XX"/>
	<array offset="0x0466" name="RBBM_PERFCTR_TSE" stride="2" length="4" variants="A6XX"/>
	<array offset="0x046e" name="RBBM_PERFCTR_RAS" stride="2" length="4" variants="A6XX"/>
	<array offset="0x0476" name="RBBM_PERFCTR_UCHE" stride="2" length="12" variants="A6XX"/>
	<array offset="0x048e" name="RBBM_PERFCTR_TP" stride="2" length="12" variants="A6XX"/>
	<array offset="0x04a6" name="RBBM_PERFCTR_SP" stride="2" length="24" variants="A6XX"/>
	<array offset="0x04d6" name="RBBM_PERFCTR_RB" stride="2" length="8" variants="A6XX"/>
	<array offset="0x04e6" name="RBBM_PERFCTR_VSC" stride="2" length="2" variants="A6XX"/>
	<array offset="0x04ea" name="RBBM_PERFCTR_LRZ" stride="2" length="4" variants="A6XX"/>
	<array offset="0x04f2" name="RBBM_PERFCTR_CMP" stride="2" length="4" variants="A6XX"/>

	<array offset="0x0300" name="RBBM_PERFCTR_CP" stride="2" length="14" variants="A7XX-"/>
	<array offset="0x031c" name="RBBM_PERFCTR_RBBM" stride="2" length="4" variants="A7XX-"/>
	<array offset="0x0324" name="RBBM_PERFCTR_PC" stride="2" length="8" variants="A7XX-"/>
	<array offset="0x0334" name="RBBM_PERFCTR_VFD" stride="2" length="8" variants="A7XX-"/>
	<array offset="0x0344" name="RBBM_PERFCTR_HLSQ" stride="2" length="6" variants="A7XX-"/>
	<array offset="0x0350" name="RBBM_PERFCTR_VPC" stride="2" length="6" variants="A7XX-"/>
	<array offset="0x035c" name="RBBM_PERFCTR_CCU" stride="2" length="5" variants="A7XX-"/>
	<array offset="0x0366" name="RBBM_PERFCTR_TSE" stride="2" length="4" variants="A7XX-"/>
	<array offset="0x036e" name="RBBM_PERFCTR_RAS" stride="2" length="4" variants="A7XX-"/>
	<array offset="0x0376" name="RBBM_PERFCTR_UCHE" stride="2" length="12" variants="A7XX-"/>
	<array offset="0x038e" name="RBBM_PERFCTR_TP" stride="2" length="12" variants="A7XX-"/>
	<array offset="0x03a6" name="RBBM_PERFCTR_SP" stride="2" length="24" variants="A7XX-"/>
	<array offset="0x03d6" name="RBBM_PERFCTR_RB" stride="2" length="8" variants="A7XX-"/>
	<array offset="0x03e6" name="RBBM_PERFCTR_VSC" stride="2" length="2" variants="A7XX-"/>
	<array offset="0x03ea" name="RBBM_PERFCTR_LRZ" stride="2" length="4" variants="A7XX-"/>
	<array offset="0x03f2" name="RBBM_PERFCTR_CMP" stride="2" length="4" variants="A7XX-"/>
	<array offset="0x03fa" name="RBBM_PERFCTR_UFC" stride="2" length="4" variants="A7XX-"/>
	<array offset="0x0410" name="RBBM_PERFCTR2_HLSQ" stride="2" length="6" variants="A7XX-"/>
	<array offset="0x041c" name="RBBM_PERFCTR2_CP" stride="2" length="7" variants="A7XX-"/>
	<array offset="0x042a" name="RBBM_PERFCTR2_SP" stride="2" length="12" variants="A7XX-"/>
	<array offset="0x0442" name="RBBM_PERFCTR2_TP" stride="2" length="6" variants="A7XX-"/>
	<array offset="0x044e" name="RBBM_PERFCTR2_UFC" stride="2" length="2" variants="A7XX-"/>
	<array offset="0x0460" name="RBBM_PERFCTR_BV_PC" stride="2" length="8" variants="A7XX-"/>
	<array offset="0x0470" name="RBBM_PERFCTR_BV_VFD" stride="2" length="8" variants="A7XX-"/>
	<array offset="0x0480" name="RBBM_PERFCTR_BV_VPC" stride="2" length="6" variants="A7XX-"/>
	<array offset="0x048c" name="RBBM_PERFCTR_BV_TSE" stride="2" length="4" variants="A7XX-"/>
	<array offset="0x0494" name="RBBM_PERFCTR_BV_RAS" stride="2" length="4" variants="A7XX-"/>
	<array offset="0x049c" name="RBBM_PERFCTR_BV_LRZ" stride="2" length="4" variants="A7XX-"/>

	<reg32 offset="0x0500" name="RBBM_PERFCTR_CNTL"/>
	<reg32 offset="0x0501" name="RBBM_PERFCTR_LOAD_CMD0"/>
	<reg32 offset="0x0502" name="RBBM_PERFCTR_LOAD_CMD1"/>
	<reg32 offset="0x0503" name="RBBM_PERFCTR_LOAD_CMD2"/>
	<reg32 offset="0x0504" name="RBBM_PERFCTR_LOAD_CMD3"/>
	<reg32 offset="0x0505" name="RBBM_PERFCTR_LOAD_VALUE_LO"/>
	<reg32 offset="0x0506" name="RBBM_PERFCTR_LOAD_VALUE_HI"/>
	<array offset="0x0507" name="RBBM_PERFCTR_RBBM_SEL" stride="1" length="4"/>
	<reg32 offset="0x050B" name="RBBM_PERFCTR_GPU_BUSY_MASKED"/>
	<reg32 offset="0x050e" name="RBBM_PERFCTR_SRAM_INIT_CMD"/>
	<reg32 offset="0x050f" name="RBBM_PERFCTR_SRAM_INIT_STATUS"/>
	<reg32 offset="0x0533" name="RBBM_ISDB_CNT"/>
	<reg32 offset="0x0534" name="RBBM_NC_MODE_CNTL"/>
	<reg32 offset="0x0535" name="RBBM_SNAPSHOT_STATUS" variants="A7XX-"/>

	<!---
	    This block of registers aren't tied to perf counters. They
	    count various geometry stats, for example number of
	    vertices in, number of primnitives assembled etc.
	-->

	<reg64 offset="0x0540" name="RBBM_PIPESTAT_IAVERTICES"/>
	<reg64 offset="0x0542" name="RBBM_PIPESTAT_IAPRIMITIVES"/>
	<reg64 offset="0x0544" name="RBBM_PIPESTAT_VSINVOCATIONS"/>
	<reg64 offset="0x0546" name="RBBM_PIPESTAT_HSINVOCATIONS"/>
	<reg64 offset="0x0548" name="RBBM_PIPESTAT_DSINVOCATIONS"/>
	<reg64 offset="0x054a" name="RBBM_PIPESTAT_GSINVOCATIONS"/>
	<reg64 offset="0x054c" name="RBBM_PIPESTAT_GSPRIMITIVES"/>
	<reg64 offset="0x054e" name="RBBM_PIPESTAT_CINVOCATIONS"/>
	<reg64 offset="0x0550" name="RBBM_PIPESTAT_CPRIMITIVES"/>
	<reg64 offset="0x0552" name="RBBM_PIPESTAT_PSINVOCATIONS"/>
	<reg64 offset="0x0554" name="RBBM_PIPESTAT_CSINVOCATIONS"/>

	<reg32 offset="0xF400" name="RBBM_SECVID_TRUST_CNTL"/>
	<reg64 offset="0xF800" name="RBBM_SECVID_TSB_TRUSTED_BASE"/>
	<reg32 offset="0xF802" name="RBBM_SECVID_TSB_TRUSTED_SIZE"/>
	<reg32 offset="0xF803" name="RBBM_SECVID_TSB_CNTL"/>
	<reg32 offset="0xF810" name="RBBM_SECVID_TSB_ADDR_MODE_CNTL" type="a5xx_address_mode"/>
	<reg64 offset="0xfc00" name="RBBM_SECVID_TSB_STATUS" variants="A7XX-"/>
	<reg32 offset="0x00010" name="RBBM_VBIF_CLIENT_QOS_CNTL"/>
	<reg32 offset="0x00011" name="RBBM_GBIF_CLIENT_QOS_CNTL"/>
	<reg32 offset="0x00016" name="RBBM_GBIF_HALT"/>
	<reg32 offset="0x00017" name="RBBM_GBIF_HALT_ACK"/>
	<reg32 offset="0x0001c" name="RBBM_WAIT_FOR_GPU_IDLE_CMD">
		<bitfield pos="0" name="WAIT_GPU_IDLE" type="boolean"/>
	</reg32>

	<reg32 offset="0x00016" name="RBBM_GBIF_HALT" variants="A7XX-"/>
	<reg32 offset="0x00017" name="RBBM_GBIF_HALT_ACK" variants="A7XX-"/>
	<reg32 offset="0x0001f" name="RBBM_INTERFACE_HANG_INT_CNTL"/>
	<reg32 offset="0x00037" name="RBBM_INT_CLEAR_CMD" type="A6XX_RBBM_INT_0_MASK"/>
	<reg32 offset="0x00038" name="RBBM_INT_0_MASK" type="A6XX_RBBM_INT_0_MASK"/>
	<reg32 offset="0x0003a" name="RBBM_INT_2_MASK" variants="A7XX-"/>
	<reg32 offset="0x00042" name="RBBM_SP_HYST_CNT"/>
	<reg32 offset="0x00043" name="RBBM_SW_RESET_CMD"/>
	<reg32 offset="0x00044" name="RBBM_RAC_THRESHOLD_CNT"/>
	<reg32 offset="0x00045" name="RBBM_BLOCK_SW_RESET_CMD"/>
	<reg32 offset="0x00046" name="RBBM_BLOCK_SW_RESET_CMD2"/>
	<reg32 offset="0x000ad" name="RBBM_CLOCK_CNTL_GLOBAL" variants="A7XX-"/>
	<reg32 offset="0x000ae" name="RBBM_CLOCK_CNTL"/>
	<reg32 offset="0x000b0" name="RBBM_CLOCK_CNTL_SP0"/>
	<reg32 offset="0x000b1" name="RBBM_CLOCK_CNTL_SP1"/>
	<reg32 offset="0x000b2" name="RBBM_CLOCK_CNTL_SP2"/>
	<reg32 offset="0x000b3" name="RBBM_CLOCK_CNTL_SP3"/>
	<reg32 offset="0x000b4" name="RBBM_CLOCK_CNTL2_SP0"/>
	<reg32 offset="0x000b5" name="RBBM_CLOCK_CNTL2_SP1"/>
	<reg32 offset="0x000b6" name="RBBM_CLOCK_CNTL2_SP2"/>
	<reg32 offset="0x000b7" name="RBBM_CLOCK_CNTL2_SP3"/>
	<reg32 offset="0x000b8" name="RBBM_CLOCK_DELAY_SP0"/>
	<reg32 offset="0x000b9" name="RBBM_CLOCK_DELAY_SP1"/>
	<reg32 offset="0x000ba" name="RBBM_CLOCK_DELAY_SP2"/>
	<reg32 offset="0x000bb" name="RBBM_CLOCK_DELAY_SP3"/>
	<reg32 offset="0x000bc" name="RBBM_CLOCK_HYST_SP0"/>
	<reg32 offset="0x000bd" name="RBBM_CLOCK_HYST_SP1"/>
	<reg32 offset="0x000be" name="RBBM_CLOCK_HYST_SP2"/>
	<reg32 offset="0x000bf" name="RBBM_CLOCK_HYST_SP3"/>
	<reg32 offset="0x000c0" name="RBBM_CLOCK_CNTL_TP0"/>
	<reg32 offset="0x000c1" name="RBBM_CLOCK_CNTL_TP1"/>
	<reg32 offset="0x000c2" name="RBBM_CLOCK_CNTL_TP2"/>
	<reg32 offset="0x000c3" name="RBBM_CLOCK_CNTL_TP3"/>
	<reg32 offset="0x000c4" name="RBBM_CLOCK_CNTL2_TP0"/>
	<reg32 offset="0x000c5" name="RBBM_CLOCK_CNTL2_TP1"/>
	<reg32 offset="0x000c6" name="RBBM_CLOCK_CNTL2_TP2"/>
	<reg32 offset="0x000c7" name="RBBM_CLOCK_CNTL2_TP3"/>
	<reg32 offset="0x000c8" name="RBBM_CLOCK_CNTL3_TP0"/>
	<reg32 offset="0x000c9" name="RBBM_CLOCK_CNTL3_TP1"/>
	<reg32 offset="0x000ca" name="RBBM_CLOCK_CNTL3_TP2"/>
	<reg32 offset="0x000cb" name="RBBM_CLOCK_CNTL3_TP3"/>
	<reg32 offset="0x000cc" name="RBBM_CLOCK_CNTL4_TP0"/>
	<reg32 offset="0x000cd" name="RBBM_CLOCK_CNTL4_TP1"/>
	<reg32 offset="0x000ce" name="RBBM_CLOCK_CNTL4_TP2"/>
	<reg32 offset="0x000cf" name="RBBM_CLOCK_CNTL4_TP3"/>
	<reg32 offset="0x000d0" name="RBBM_CLOCK_DELAY_TP0"/>
	<reg32 offset="0x000d1" name="RBBM_CLOCK_DELAY_TP1"/>
	<reg32 offset="0x000d2" name="RBBM_CLOCK_DELAY_TP2"/>
	<reg32 offset="0x000d3" name="RBBM_CLOCK_DELAY_TP3"/>
	<reg32 offset="0x000d4" name="RBBM_CLOCK_DELAY2_TP0"/>
	<reg32 offset="0x000d5" name="RBBM_CLOCK_DELAY2_TP1"/>
	<reg32 offset="0x000d6" name="RBBM_CLOCK_DELAY2_TP2"/>
	<reg32 offset="0x000d7" name="RBBM_CLOCK_DELAY2_TP3"/>
	<reg32 offset="0x000d8" name="RBBM_CLOCK_DELAY3_TP0"/>
	<reg32 offset="0x000d9" name="RBBM_CLOCK_DELAY3_TP1"/>
	<reg32 offset="0x000da" name="RBBM_CLOCK_DELAY3_TP2"/>
	<reg32 offset="0x000db" name="RBBM_CLOCK_DELAY3_TP3"/>
	<reg32 offset="0x000dc" name="RBBM_CLOCK_DELAY4_TP0"/>
	<reg32 offset="0x000dd" name="RBBM_CLOCK_DELAY4_TP1"/>
	<reg32 offset="0x000de" name="RBBM_CLOCK_DELAY4_TP2"/>
	<reg32 offset="0x000df" name="RBBM_CLOCK_DELAY4_TP3"/>
	<reg32 offset="0x000e0" name="RBBM_CLOCK_HYST_TP0"/>
	<reg32 offset="0x000e1" name="RBBM_CLOCK_HYST_TP1"/>
	<reg32 offset="0x000e2" name="RBBM_CLOCK_HYST_TP2"/>
	<reg32 offset="0x000e3" name="RBBM_CLOCK_HYST_TP3"/>
	<reg32 offset="0x000e4" name="RBBM_CLOCK_HYST2_TP0"/>
	<reg32 offset="0x000e5" name="RBBM_CLOCK_HYST2_TP1"/>
	<reg32 offset="0x000e6" name="RBBM_CLOCK_HYST2_TP2"/>
	<reg32 offset="0x000e7" name="RBBM_CLOCK_HYST2_TP3"/>
	<reg32 offset="0x000e8" name="RBBM_CLOCK_HYST3_TP0"/>
	<reg32 offset="0x000e9" name="RBBM_CLOCK_HYST3_TP1"/>
	<reg32 offset="0x000ea" name="RBBM_CLOCK_HYST3_TP2"/>
	<reg32 offset="0x000eb" name="RBBM_CLOCK_HYST3_TP3"/>
	<reg32 offset="0x000ec" name="RBBM_CLOCK_HYST4_TP0"/>
	<reg32 offset="0x000ed" name="RBBM_CLOCK_HYST4_TP1"/>
	<reg32 offset="0x000ee" name="RBBM_CLOCK_HYST4_TP2"/>
	<reg32 offset="0x000ef" name="RBBM_CLOCK_HYST4_TP3"/>
	<reg32 offset="0x000f0" name="RBBM_CLOCK_CNTL_RB0"/>
	<reg32 offset="0x000f1" name="RBBM_CLOCK_CNTL_RB1"/>
	<reg32 offset="0x000f2" name="RBBM_CLOCK_CNTL_RB2"/>
	<reg32 offset="0x000f3" name="RBBM_CLOCK_CNTL_RB3"/>
	<reg32 offset="0x000f4" name="RBBM_CLOCK_CNTL2_RB0"/>
	<reg32 offset="0x000f5" name="RBBM_CLOCK_CNTL2_RB1"/>
	<reg32 offset="0x000f6" name="RBBM_CLOCK_CNTL2_RB2"/>
	<reg32 offset="0x000f7" name="RBBM_CLOCK_CNTL2_RB3"/>
	<reg32 offset="0x000f8" name="RBBM_CLOCK_CNTL_CCU0"/>
	<reg32 offset="0x000f9" name="RBBM_CLOCK_CNTL_CCU1"/>
	<reg32 offset="0x000fa" name="RBBM_CLOCK_CNTL_CCU2"/>
	<reg32 offset="0x000fb" name="RBBM_CLOCK_CNTL_CCU3"/>
	<reg32 offset="0x00100" name="RBBM_CLOCK_HYST_RB_CCU0"/>
	<reg32 offset="0x00101" name="RBBM_CLOCK_HYST_RB_CCU1"/>
	<reg32 offset="0x00102" name="RBBM_CLOCK_HYST_RB_CCU2"/>
	<reg32 offset="0x00103" name="RBBM_CLOCK_HYST_RB_CCU3"/>
	<reg32 offset="0x00104" name="RBBM_CLOCK_CNTL_RAC"/>
	<reg32 offset="0x00105" name="RBBM_CLOCK_CNTL2_RAC"/>
	<reg32 offset="0x00106" name="RBBM_CLOCK_DELAY_RAC"/>
	<reg32 offset="0x00107" name="RBBM_CLOCK_HYST_RAC"/>
	<reg32 offset="0x00108" name="RBBM_CLOCK_CNTL_TSE_RAS_RBBM"/>
	<reg32 offset="0x00109" name="RBBM_CLOCK_DELAY_TSE_RAS_RBBM"/>
	<reg32 offset="0x0010a" name="RBBM_CLOCK_HYST_TSE_RAS_RBBM"/>
	<reg32 offset="0x0010b" name="RBBM_CLOCK_CNTL_UCHE"/>
	<reg32 offset="0x0010c" name="RBBM_CLOCK_CNTL2_UCHE"/>
	<reg32 offset="0x0010d" name="RBBM_CLOCK_CNTL3_UCHE"/>
	<reg32 offset="0x0010e" name="RBBM_CLOCK_CNTL4_UCHE"/>
	<reg32 offset="0x0010f" name="RBBM_CLOCK_DELAY_UCHE"/>
	<reg32 offset="0x00110" name="RBBM_CLOCK_HYST_UCHE"/>
	<reg32 offset="0x00111" name="RBBM_CLOCK_MODE_VFD"/>
	<reg32 offset="0x00112" name="RBBM_CLOCK_DELAY_VFD"/>
	<reg32 offset="0x00113" name="RBBM_CLOCK_HYST_VFD"/>
	<reg32 offset="0x00114" name="RBBM_CLOCK_MODE_GPC"/>
	<reg32 offset="0x00115" name="RBBM_CLOCK_DELAY_GPC"/>
	<reg32 offset="0x00116" name="RBBM_CLOCK_HYST_GPC"/>
	<reg32 offset="0x00117" name="RBBM_CLOCK_DELAY_HLSQ_2"/>
	<reg32 offset="0x00118" name="RBBM_CLOCK_CNTL_GMU_GX"/>
	<reg32 offset="0x00119" name="RBBM_CLOCK_DELAY_GMU_GX"/>
	<reg32 offset="0x0011a" name="RBBM_CLOCK_HYST_GMU_GX"/>
	<reg32 offset="0x0011b" name="RBBM_CLOCK_MODE_HLSQ"/>
	<reg32 offset="0x0011c" name="RBBM_CLOCK_DELAY_HLSQ"/>
	<reg32 offset="0x0011d" name="RBBM_CLOCK_HYST_HLSQ"/>
	<reg32 offset="0x0011e" name="RBBM_CGC_GLOBAL_LOAD_CMD" variants="A7XX-"/>
	<reg32 offset="0x0011f" name="RBBM_CGC_P2S_TRIG_CMD" variants="A7XX-"/>
	<reg32 offset="0x00120" name="RBBM_CLOCK_CNTL_TEX_FCHE"/>
	<reg32 offset="0x00121" name="RBBM_CLOCK_DELAY_TEX_FCHE"/>
	<reg32 offset="0x00122" name="RBBM_CLOCK_HYST_TEX_FCHE" variants="A6XX"/>
	<reg32 offset="0x00122" name="RBBM_CGC_P2S_STATUS" variants="A7XX-">
		<bitfield name="TXDONE" pos="0" type="boolean"/>
	</reg32>
	<reg32 offset="0x00123" name="RBBM_CLOCK_CNTL_FCHE"/>
	<reg32 offset="0x00124" name="RBBM_CLOCK_DELAY_FCHE"/>
	<reg32 offset="0x00125" name="RBBM_CLOCK_HYST_FCHE"/>
	<reg32 offset="0x00126" name="RBBM_CLOCK_CNTL_MHUB"/>
	<reg32 offset="0x00127" name="RBBM_CLOCK_DELAY_MHUB"/>
	<reg32 offset="0x00128" name="RBBM_CLOCK_HYST_MHUB"/>
	<reg32 offset="0x00129" name="RBBM_CLOCK_DELAY_GLC"/>
	<reg32 offset="0x0012a" name="RBBM_CLOCK_HYST_GLC"/>
	<reg32 offset="0x0012b" name="RBBM_CLOCK_CNTL_GLC"/>
	<reg32 offset="0x0012f" name="RBBM_CLOCK_HYST2_VFD" variants="A7XX-"/>
	<reg32 offset="0x005ff" name="RBBM_LPAC_GBIF_CLIENT_QOS_CNTL"/>

	<reg32 offset="0x0600" name="DBGC_CFG_DBGBUS_SEL_A"/>
	<reg32 offset="0x0601" name="DBGC_CFG_DBGBUS_SEL_B"/>
	<reg32 offset="0x0602" name="DBGC_CFG_DBGBUS_SEL_C"/>
	<reg32 offset="0x0603" name="DBGC_CFG_DBGBUS_SEL_D" variants="A6XX">
		<bitfield high="7" low="0" name="PING_INDEX"/>
		<bitfield high="15" low="8" name="PING_BLK_SEL"/>
	</reg32>
	<reg32 offset="0x0603" name="DBGC_CFG_DBGBUS_SEL_D" variants="A7XX-">
		<bitfield high="7" low="0" name="PING_INDEX"/>
		<bitfield high="24" low="16" name="PING_BLK_SEL"/>
	</reg32>
	<reg32 offset="0x0604" name="DBGC_CFG_DBGBUS_CNTLT">
		<bitfield high="5" low="0" name="TRACEEN"/>
		<bitfield high="14" low="12" name="GRANU"/>
		<bitfield high="31" low="28" name="SEGT"/>
	</reg32>
	<reg32 offset="0x0605" name="DBGC_CFG_DBGBUS_CNTLM">
		<bitfield high="27" low="24" name="ENABLE"/>
	</reg32>
	<reg32 offset="0x0608" name="DBGC_CFG_DBGBUS_IVTL_0"/>
	<reg32 offset="0x0609" name="DBGC_CFG_DBGBUS_IVTL_1"/>
	<reg32 offset="0x060a" name="DBGC_CFG_DBGBUS_IVTL_2"/>
	<reg32 offset="0x060b" name="DBGC_CFG_DBGBUS_IVTL_3"/>
	<reg32 offset="0x060c" name="DBGC_CFG_DBGBUS_MASKL_0"/>
	<reg32 offset="0x060d" name="DBGC_CFG_DBGBUS_MASKL_1"/>
	<reg32 offset="0x060e" name="DBGC_CFG_DBGBUS_MASKL_2"/>
	<reg32 offset="0x060f" name="DBGC_CFG_DBGBUS_MASKL_3"/>
	<reg32 offset="0x0610" name="DBGC_CFG_DBGBUS_BYTEL_0">
		<bitfield high="3" low="0" name="BYTEL0"/>
		<bitfield high="7" low="4" name="BYTEL1"/>
		<bitfield high="11" low="8" name="BYTEL2"/>
		<bitfield high="15" low="12" name="BYTEL3"/>
		<bitfield high="19" low="16" name="BYTEL4"/>
		<bitfield high="23" low="20" name="BYTEL5"/>
		<bitfield high="27" low="24" name="BYTEL6"/>
		<bitfield high="31" low="28" name="BYTEL7"/>
	</reg32>
	<reg32 offset="0x0611" name="DBGC_CFG_DBGBUS_BYTEL_1">
		<bitfield high="3" low="0" name="BYTEL8"/>
		<bitfield high="7" low="4" name="BYTEL9"/>
		<bitfield high="11" low="8" name="BYTEL10"/>
		<bitfield high="15" low="12" name="BYTEL11"/>
		<bitfield high="19" low="16" name="BYTEL12"/>
		<bitfield high="23" low="20" name="BYTEL13"/>
		<bitfield high="27" low="24" name="BYTEL14"/>
		<bitfield high="31" low="28" name="BYTEL15"/>
	</reg32>
	<reg32 offset="0x062f" name="DBGC_CFG_DBGBUS_TRACE_BUF1"/>
	<reg32 offset="0x0630" name="DBGC_CFG_DBGBUS_TRACE_BUF2"/>
	<array offset="0x0CD8" name="VSC_PERFCTR_VSC_SEL" stride="1" length="2" variants="A6XX"/>
	<reg32 offset="0x0CD8" name="VSC_UNKNOWN_0CD8" variants="A7XX">
		<doc>
			Set to true when binning, isn't changed afterwards
		</doc>
		<bitfield name="BINNING" pos="0" type="boolean"/>
	</reg32>
	<reg32 offset="0xC800" name="HLSQ_DBG_AHB_READ_APERTURE"/>
	<reg32 offset="0xD000" name="HLSQ_DBG_READ_SEL"/>
	<reg32 offset="0x0E00" name="UCHE_ADDR_MODE_CNTL" type="a5xx_address_mode"/>
	<reg32 offset="0x0E01" name="UCHE_MODE_CNTL"/>
	<reg64 offset="0x0E05" name="UCHE_WRITE_RANGE_MAX"/>
	<reg64 offset="0x0E07" name="UCHE_WRITE_THRU_BASE"/>
	<reg64 offset="0x0E09" name="UCHE_TRAP_BASE"/>
	<reg64 offset="0x0E0B" name="UCHE_GMEM_RANGE_MIN"/>
	<reg64 offset="0x0E0D" name="UCHE_GMEM_RANGE_MAX"/>
	<reg32 offset="0x0E17" name="UCHE_CACHE_WAYS" usage="cmd"/>
	<reg32 offset="0x0E18" name="UCHE_FILTER_CNTL"/>
	<reg32 offset="0x0E19" name="UCHE_CLIENT_PF" usage="cmd">
		<bitfield high="7" low="0" name="PERFSEL"/>
	</reg32>
	<array offset="0x0E1C" name="UCHE_PERFCTR_UCHE_SEL" stride="1" length="12"/>
	<reg32 offset="0x0e3a" name="UCHE_GBIF_GX_CONFIG"/>
	<reg32 offset="0x0e3c" name="UCHE_CMDQ_CONFIG"/>

	<reg32 offset="0x3000" name="VBIF_VERSION"/>
	<reg32 offset="0x3001" name="VBIF_CLKON">
		<bitfield pos="1" name="FORCE_ON_TESTBUS" type="boolean"/>
	</reg32>
	<reg32 offset="0x302A" name="VBIF_GATE_OFF_WRREQ_EN"/>
	<reg32 offset="0x3080" name="VBIF_XIN_HALT_CTRL0"/>
	<reg32 offset="0x3081" name="VBIF_XIN_HALT_CTRL1"/>
	<reg32 offset="0x3084" name="VBIF_TEST_BUS_OUT_CTRL"/>
	<reg32 offset="0x3085" name="VBIF_TEST_BUS1_CTRL0"/>
	<reg32 offset="0x3086" name="VBIF_TEST_BUS1_CTRL1">
		<bitfield low="0" high="3" name="DATA_SEL"/>
	</reg32>
	<reg32 offset="0x3087" name="VBIF_TEST_BUS2_CTRL0"/>
	<reg32 offset="0x3088" name="VBIF_TEST_BUS2_CTRL1">
		<bitfield low="0" high="8" name="DATA_SEL"/>
	</reg32>
	<reg32 offset="0x308c" name="VBIF_TEST_BUS_OUT"/>
	<reg32 offset="0x30d0" name="VBIF_PERF_CNT_SEL0"/>
	<reg32 offset="0x30d1" name="VBIF_PERF_CNT_SEL1"/>
	<reg32 offset="0x30d2" name="VBIF_PERF_CNT_SEL2"/>
	<reg32 offset="0x30d3" name="VBIF_PERF_CNT_SEL3"/>
	<reg32 offset="0x30d8" name="VBIF_PERF_CNT_LOW0"/>
	<reg32 offset="0x30d9" name="VBIF_PERF_CNT_LOW1"/>
	<reg32 offset="0x30da" name="VBIF_PERF_CNT_LOW2"/>
	<reg32 offset="0x30db" name="VBIF_PERF_CNT_LOW3"/>
	<reg32 offset="0x30e0" name="VBIF_PERF_CNT_HIGH0"/>
	<reg32 offset="0x30e1" name="VBIF_PERF_CNT_HIGH1"/>
	<reg32 offset="0x30e2" name="VBIF_PERF_CNT_HIGH2"/>
	<reg32 offset="0x30e3" name="VBIF_PERF_CNT_HIGH3"/>
	<reg32 offset="0x3100" name="VBIF_PERF_PWR_CNT_EN0"/>
	<reg32 offset="0x3101" name="VBIF_PERF_PWR_CNT_EN1"/>
	<reg32 offset="0x3102" name="VBIF_PERF_PWR_CNT_EN2"/>
	<reg32 offset="0x3110" name="VBIF_PERF_PWR_CNT_LOW0"/>
	<reg32 offset="0x3111" name="VBIF_PERF_PWR_CNT_LOW1"/>
	<reg32 offset="0x3112" name="VBIF_PERF_PWR_CNT_LOW2"/>
	<reg32 offset="0x3118" name="VBIF_PERF_PWR_CNT_HIGH0"/>
	<reg32 offset="0x3119" name="VBIF_PERF_PWR_CNT_HIGH1"/>
	<reg32 offset="0x311a" name="VBIF_PERF_PWR_CNT_HIGH2"/>

	<reg32 offset="0x3c01" name="GBIF_SCACHE_CNTL0"/>
	<reg32 offset="0x3c02" name="GBIF_SCACHE_CNTL1"/>
	<reg32 offset="0x3c03" name="GBIF_QSB_SIDE0"/>
	<reg32 offset="0x3c04" name="GBIF_QSB_SIDE1"/>
	<reg32 offset="0x3c05" name="GBIF_QSB_SIDE2"/>
	<reg32 offset="0x3c06" name="GBIF_QSB_SIDE3"/>
	<reg32 offset="0x3c45" name="GBIF_HALT"/>
	<reg32 offset="0x3c46" name="GBIF_HALT_ACK"/>
	<reg32 offset="0x3cc0" name="GBIF_PERF_PWR_CNT_EN"/>
	<reg32 offset="0x3cc1" name="GBIF_PERF_PWR_CNT_CLR"/>
	<reg32 offset="0x3cc2" name="GBIF_PERF_CNT_SEL"/>
	<reg32 offset="0x3cc3" name="GBIF_PERF_PWR_CNT_SEL"/>
	<reg32 offset="0x3cc4" name="GBIF_PERF_CNT_LOW0"/>
	<reg32 offset="0x3cc5" name="GBIF_PERF_CNT_LOW1"/>
	<reg32 offset="0x3cc6" name="GBIF_PERF_CNT_LOW2"/>
	<reg32 offset="0x3cc7" name="GBIF_PERF_CNT_LOW3"/>
	<reg32 offset="0x3cc8" name="GBIF_PERF_CNT_HIGH0"/>
	<reg32 offset="0x3cc9" name="GBIF_PERF_CNT_HIGH1"/>
	<reg32 offset="0x3cca" name="GBIF_PERF_CNT_HIGH2"/>
	<reg32 offset="0x3ccb" name="GBIF_PERF_CNT_HIGH3"/>
	<reg32 offset="0x3ccc" name="GBIF_PWR_CNT_LOW0"/>
	<reg32 offset="0x3ccd" name="GBIF_PWR_CNT_LOW1"/>
	<reg32 offset="0x3cce" name="GBIF_PWR_CNT_LOW2"/>
	<reg32 offset="0x3ccf" name="GBIF_PWR_CNT_HIGH0"/>
	<reg32 offset="0x3cd0" name="GBIF_PWR_CNT_HIGH1"/>
	<reg32 offset="0x3cd1" name="GBIF_PWR_CNT_HIGH2"/>

	<reg32 offset="0x0c00" name="VSC_DBG_ECO_CNTL"/>
	<reg32 offset="0x0c02" name="VSC_BIN_SIZE" usage="rp_blit">
		<bitfield name="WIDTH" low="0" high="7" shr="5" type="uint"/>
		<bitfield name="HEIGHT" low="8" high="16" shr="4" type="uint"/>
	</reg32>
	<reg64 offset="0x0c03" name="VSC_SIZE_BASE" type="waddress" usage="cmd"/>
	<reg32 offset="0x0c06" name="VSC_EXPANDED_BIN_CNTL" usage="rp_blit">
		<bitfield name="NX" low="1" high="10" type="uint"/>
		<bitfield name="NY" low="11" high="20" type="uint"/>
	</reg32>
	<array offset="0x0c10" name="VSC_PIPE_CONFIG" stride="1" length="32" usage="rp_blit">
		<reg32 offset="0x0" name="REG">
			<doc>
				Configures the mapping between VSC_PIPE buffer and
				bin, X/Y specify the bin index in the horiz/vert
				direction (0,0 is upper left, 0,1 is leftmost bin
				on second row, and so on).  W/H specify the number
				of bins assigned to this VSC_PIPE in the horiz/vert
				dimension.
			</doc>
			<bitfield name="X" low="0" high="9" type="uint"/>
			<bitfield name="Y" low="10" high="19" type="uint"/>
			<bitfield name="W" low="20" high="25" type="uint"/>
			<bitfield name="H" low="26" high="31" type="uint"/>
		</reg32>
	</array>
	<!--
	HW binning primitive & draw streams, which enable draws and primitives
	within a draw to be skipped in the main tile pass.  See:
	https://github.com/freedreno/freedreno/wiki/Visibility-Stream-Format

	Compared to a5xx and earlier, we just program the address of the first
	stream and hw adds (pipe_num * VSC_*_STRM_PITCH)

	LIMIT is set to PITCH - 64, to make room for a bit of overflow
	 -->
	<reg64 offset="0x0c30" name="VSC_PIPE_DATA_PRIM_BASE" type="waddress" usage="cmd"/>
	<reg32 offset="0x0c32" name="VSC_PIPE_DATA_PRIM_STRIDE" usage="cmd"/>
	<reg32 offset="0x0c33" name="VSC_PIPE_DATA_PRIM_LENGTH" usage="cmd"/>
	<reg64 offset="0x0c34" name="VSC_PIPE_DATA_DRAW_BASE" type="waddress" usage="cmd"/>
	<reg32 offset="0x0c36" name="VSC_PIPE_DATA_DRAW_STRIDE" usage="cmd"/>
	<reg32 offset="0x0c37" name="VSC_PIPE_DATA_DRAW_LENGTH" usage="cmd"/>

	<array offset="0x0c38" name="VSC_CHANNEL_VISIBILITY" stride="1" length="32" usage="rp_blit">
		<doc>
			Seems to be a bitmap of which tiles mapped to the VSC
			pipe contain geometry.

			I suppose we can connect a maximum of 32 tiles to a
			single VSC pipe.
		</doc>
		<reg32 offset="0x0" name="REG"/>
	</array>

	<array offset="0x0c58" name="VSC_PIPE_DATA_PRIM_SIZE" stride="1" length="32" variants="A6XX" usage="rp_blit">
		<doc>
			Has the size of data written to corresponding VSC_PRIM_STRM
			buffer.
		</doc>
		<reg32 offset="0x0" name="REG"/>
	</array>

	<array offset="0x0c78" name="VSC_PIPE_DATA_DRAW_SIZE" stride="1" length="32" variants="A6XX" usage="rp_blit">
		<doc>
			Has the size of data written to corresponding VSC pipe, ie.
			same thing that is written out to VSC_SIZE_BASE
		</doc>
		<reg32 offset="0x0" name="REG"/>
	</array>

	<reg32 offset="0x0d08" name="VSC_UNKNOWN_0D08" variants="A7XX-" usage="rp_blit"/>

	<reg32 offset="0x0E10" name="UCHE_UNKNOWN_0E10" variants="A7XX-" usage="cmd"/>
	<reg32 offset="0x0E11" name="UCHE_UNKNOWN_0E11" variants="A7XX-" usage="cmd"/>
	<!-- always 0x03200000 ? -->
	<reg32 offset="0x0e12" name="UCHE_UNKNOWN_0E12"  usage="cmd"/>

	<!-- adreno_reg_xy has 15 bits per coordinate, but a6xx registers only have 14 -->
	<bitset name="a6xx_reg_xy" inline="yes">
		<bitfield name="X" low="0" high="13" type="uint"/>
		<bitfield name="Y" low="16" high="29" type="uint"/>
	</bitset>

	<bitset name="a6xx_gras_cl_cntl" inline="yes">
		<bitfield name="CLIP_DISABLE" pos="0" type="boolean"/>
		<bitfield name="ZNEAR_CLIP_DISABLE" pos="1" type="boolean"/>
		<bitfield name="ZFAR_CLIP_DISABLE" pos="2" type="boolean"/>
		<bitfield name="Z_CLAMP_ENABLE" pos="5" type="boolean"/>
		<!-- controls near z clip behavior (set for vulkan) -->
		<bitfield name="ZERO_GB_SCALE_Z" pos="6" type="boolean"/>
		<!-- guess based on a3xx and meaning of bits 8 and 9
		     if the guess is right then this is related to point sprite clipping -->
		<bitfield name="VP_CLIP_CODE_IGNORE" pos="7" type="boolean"/>
		<bitfield name="VP_XFORM_DISABLE" pos="8" type="boolean"/>
		<bitfield name="PERSP_DIVISION_DISABLE" pos="9" type="boolean"/>
	</bitset>

	<reg32 offset="0x8000" name="GRAS_CL_CNTL" type="a6xx_gras_cl_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_gras_xs_clip_cull_distance" inline="yes">
		<bitfield name="CLIP_MASK" low="0" high="7"/>
		<bitfield name="CULL_MASK" low="8" high="15"/>
	</bitset>
	<reg32 offset="0x8001" name="GRAS_CL_VS_CLIP_CULL_DISTANCE" type="a6xx_gras_xs_clip_cull_distance" usage="rp_blit" variants="A6XX-A7XX" />
	<reg32 offset="0x8002" name="GRAS_CL_DS_CLIP_CULL_DISTANCE" type="a6xx_gras_xs_clip_cull_distance" usage="rp_blit" variants="A6XX-A7XX" />
	<reg32 offset="0x8003" name="GRAS_CL_GS_CLIP_CULL_DISTANCE" type="a6xx_gras_xs_clip_cull_distance" usage="rp_blit" variants="A6XX-A7XX" />
	<reg32 offset="0x8004" name="GRAS_CL_ARRAY_SIZE" low="0" high="10" type="uint" usage="rp_blit" variants="A6XX-A7XX" />

	<bitset name="a6xx_gras_cl_interp_cntl" inline="yes">
		<!-- see also RB_INTERP_CNTL -->
		<bitfield name="IJ_PERSP_PIXEL" pos="0" type="boolean"/>
		<bitfield name="IJ_PERSP_CENTROID" pos="1" type="boolean"/>
		<bitfield name="IJ_PERSP_SAMPLE" pos="2" type="boolean"/>
		<bitfield name="IJ_LINEAR_PIXEL" pos="3" type="boolean"/>
		<bitfield name="IJ_LINEAR_CENTROID" pos="4" type="boolean"/>
		<bitfield name="IJ_LINEAR_SAMPLE" pos="5" type="boolean"/>
		<bitfield name="COORD_MASK" low="6" high="9" type="hex"/>
		<bitfield name="UNK10" pos="10" type="boolean" variants="A7XX-"/>
		<bitfield name="UNK11" pos="11" type="boolean" variants="A7XX-"/>
	</bitset>

	<reg32 offset="0x8005" name="GRAS_CL_INTERP_CNTL" type="a6xx_gras_cl_interp_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_gras_cl_guardband_clip_adj" inline="true">
		<bitfield name="HORZ" low="0" high="8" type="uint"/>
		<bitfield name="VERT" low="10" high="18" type="uint"/>
	</bitset>

	<reg32 offset="0x8006" name="GRAS_CL_GUARDBAND_CLIP_ADJ" type="a6xx_gras_cl_guardband_clip_adj" variants="A6XX-A7XX" usage="rp_blit"/>

	<!-- Something connected to depth-stencil attachment size -->
	<reg32 offset="0x8007" name="GRAS_UNKNOWN_8007" variants="A7XX-" usage="rp_blit"/>

	<!-- the scale/offset is per view, with up to 6 views -->
	<bitset name="a6xx_gras_bin_foveat" inline="yes">
		<bitfield name="BINSCALEEN" pos="6" type="boolean"/>
		<enum name="a7xx_bin_scale">
			<value value="0" name="NOSCALE"/>
			<value value="1" name="SCALE2X"/>
			<value value="2" name="SCALE4X"/>
		</enum>
		<bitfield name="XSCALE_0" low="8" high="9" type="a7xx_bin_scale"/>
		<bitfield name="YSCALE_0" low="10" high="11" type="a7xx_bin_scale"/>
		<bitfield name="XSCALE_1" low="12" high="13" type="a7xx_bin_scale"/>
		<bitfield name="YSCALE_1" low="14" high="15" type="a7xx_bin_scale"/>
		<bitfield name="XSCALE_2" low="16" high="17" type="a7xx_bin_scale"/>
		<bitfield name="YSCALE_2" low="18" high="19" type="a7xx_bin_scale"/>
		<bitfield name="XSCALE_3" low="20" high="21" type="a7xx_bin_scale"/>
		<bitfield name="YSCALE_3" low="22" high="23" type="a7xx_bin_scale"/>
		<bitfield name="XSCALE_4" low="24" high="25" type="a7xx_bin_scale"/>
		<bitfield name="YSCALE_4" low="26" high="27" type="a7xx_bin_scale"/>
		<bitfield name="XSCALE_5" low="28" high="29" type="a7xx_bin_scale"/>
		<bitfield name="YSCALE_5" low="30" high="31" type="a7xx_bin_scale"/>
	</bitset>

	<reg32 offset="0x8008" name="GRAS_BIN_FOVEAT" type="a6xx_gras_bin_foveat" variants="A7XX" usage="cmd"/>

	<reg32 offset="0x8009" name="GRAS_BIN_FOVEAT_OFFSET_0" variants="A7XX-" usage="cmd">
		<bitfield name="XOFFSET_0" low="0" high="9" shr="2" type="uint"/>
		<bitfield name="XOFFSET_1" low="10" high="19" shr="2" type="uint"/>
		<bitfield name="XOFFSET_2" low="20" high="29" shr="2" type="uint"/>
	</reg32>
	<reg32 offset="0x800a" name="GRAS_BIN_FOVEAT_OFFSET_1" variants="A7XX-" usage="cmd">
		<bitfield name="XOFFSET_3" low="0" high="9" shr="2" type="uint"/>
		<bitfield name="XOFFSET_4" low="10" high="19" shr="2" type="uint"/>
		<bitfield name="XOFFSET_5" low="20" high="29" shr="2" type="uint"/>
	</reg32>
	<reg32 offset="0x800b" name="GRAS_BIN_FOVEAT_OFFSET_2" variants="A7XX-" usage="cmd">
		<bitfield name="YOFFSET_0" low="0" high="9" shr="2" type="uint"/>
		<bitfield name="YOFFSET_1" low="10" high="19" shr="2" type="uint"/>
		<bitfield name="YOFFSET_2" low="20" high="29" shr="2" type="uint"/>
	</reg32>
	<reg32 offset="0x800c" name="GRAS_BIN_FOVEAT_OFFSET_3" variants="A7XX-" usage="cmd">
		<bitfield name="YOFFSET_3" low="0" high="9" shr="2" type="uint"/>
		<bitfield name="YOFFSET_4" low="10" high="19" shr="2" type="uint"/>
		<bitfield name="YOFFSET_5" low="20" high="29" shr="2" type="uint"/>
	</reg32>

	<!-- <reg32 offset="0x80f0" name="GRAS_UNKNOWN_80F0" type="a6xx_reg_xy"/> -->

	<!-- 0x8006-0x800f invalid -->
	<array offset="0x8010" name="GRAS_CL_VIEWPORT" stride="6" length="16" variants="A6XX-A7XX" usage="rp_blit">
		<reg32 offset="0" name="XOFFSET" type="float"/>
		<reg32 offset="1" name="XSCALE" type="float"/>
		<reg32 offset="2" name="YOFFSET" type="float"/>
		<reg32 offset="3" name="YSCALE" type="float"/>
		<reg32 offset="4" name="ZOFFSET" type="float"/>
		<reg32 offset="5" name="ZSCALE" type="float"/>
	</array>

	<array offset="0x8070" name="GRAS_CL_VIEWPORT_ZCLAMP" stride="2" length="16" variants="A6XX-A7XX" usage="rp_blit">
		<reg32 offset="0" name="MIN" type="float"/>
		<reg32 offset="1" name="MAX" type="float"/>
	</array>

	<bitset name="a6xx_gras_su_cntl" varset="chip">
		<bitfield name="CULL_FRONT" pos="0" type="boolean"/>
		<bitfield name="CULL_BACK" pos="1" type="boolean"/>
		<bitfield name="FRONT_CW" pos="2" type="boolean"/>
		<bitfield name="LINEHALFWIDTH" low="3" high="10" radix="2" type="fixed"/>
		<bitfield name="POLY_OFFSET" pos="11" type="boolean"/>
		<bitfield name="UNK12" pos="12"/>
		<bitfield name="LINE_MODE" pos="13" type="a5xx_line_mode"/>
		<bitfield name="UNK15" low="15" high="16"/>
		<!--
			On gen1 only MULTIVIEW_ENABLE exists. On gen3 we have
			the ability to add the view index to either the RT array
			index or the viewport index, and it seems that
			MULTIVIEW_ENABLE doesn't do anything, instead we need to
			set at least one of RENDERTARGETINDEXINCR or
			VIEWPORTINDEXINCR to enable multiview. The blob still
			sets MULTIVIEW_ENABLE regardless.
			TODO: what about gen2 (a640)?
		-->
		<bitfield name="MULTIVIEW_ENABLE" pos="17" type="boolean"/>
		<bitfield name="RENDERTARGETINDEXINCR" pos="18" type="boolean" variants="A6XX-A7XX"/>
		<bitfield name="VIEWPORTINDEXINCR" pos="19" type="boolean" variants="A6XX-A7XX"/>
		<bitfield name="UNK20" low="20" high="22" variants="A6XX-A7XX"/>
	</bitset>
	<reg32 offset="0x8090" name="GRAS_SU_CNTL" type="a6xx_gras_su_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_gras_su_point_minmax" inline="yes">
		<bitfield name="MIN" low="0" high="15" type="ufixed" radix="4"/>
		<bitfield name="MAX" low="16" high="31" type="ufixed" radix="4"/>
	</bitset>

	<reg32 offset="0x8091" name="GRAS_SU_POINT_MINMAX" type="a6xx_gras_su_point_minmax" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x8092" name="GRAS_SU_POINT_SIZE" low="0" high="15" type="fixed" radix="4" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_gras_su_depth_cntl" inline="yes">
		<bitfield name="Z_TEST_ENABLE" pos="0" type="boolean"/>
	</bitset>

	<reg32 offset="0x8114" name="GRAS_SU_DEPTH_CNTL" variants="A6XX-A7XX" type="a6xx_gras_su_depth_cntl" usage="rp_blit"/>

	<bitset name="a6xx_gras_su_stencil_cntl" inline="yes">
		<bitfield name="STENCIL_ENABLE" pos="0" type="boolean"/>
	</bitset>

	<reg32 offset="0x8115" name="GRAS_SU_STENCIL_CNTL" type="a6xx_gras_su_stencil_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_gras_su_render_cntl" inline="yes">
		<bitfield name="FS_DISABLE" pos="7" type="boolean"/>
	</bitset>

	<reg32 offset="0x8116" name="GRAS_SU_RENDER_CNTL" type="a6xx_gras_su_render_cntl" variants="A7XX" usage="rp_blit"/>

	<!-- 0x8093 invalid -->
	<bitset name="a6xx_depth_plane_cntl" inline="yes">
		<bitfield name="Z_MODE" low="0" high="1" type="a6xx_ztest_mode"/>
	</bitset>

	<reg32 offset="0x8094" name="GRAS_SU_DEPTH_PLANE_CNTL" type="a6xx_depth_plane_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x8095" name="GRAS_SU_POLY_OFFSET_SCALE" type="float" variants="A6XX-A7XX"  usage="rp_blit"/>
	<reg32 offset="0x8096" name="GRAS_SU_POLY_OFFSET_OFFSET" type="float" variants="A6XX-A7XX"  usage="rp_blit"/>
	<reg32 offset="0x8097" name="GRAS_SU_POLY_OFFSET_OFFSET_CLAMP" type="float" variants="A6XX-A7XX" usage="rp_blit"/>
	<bitset name="a6xx_depth_buffer_info" inline="yes">
		<bitfield name="DEPTH_FORMAT" low="0" high="2" type="a6xx_depth_format"/>
		<bitfield name="UNK3" pos="3"/>
	</bitset>

	<!-- duplicates RB_DEPTH_BUFFER_INFO: -->
	<reg32 offset="0x8098" name="GRAS_SU_DEPTH_BUFFER_INFO" type="a6xx_depth_buffer_info" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_gras_su_conservative_ras_cntl" inline="yes">
		<bitfield name="CONSERVATIVERASEN" pos="0" type="boolean"/>
		<enum name="a6xx_shift_amount">
			<value value="0" name="NO_SHIFT"/>
			<value value="1" name="HALF_PIXEL_SHIFT"/>
			<value value="2" name="FULL_PIXEL_SHIFT"/>
		</enum>
		<bitfield name="SHIFTAMOUNT" low="1" high="2" type="a6xx_shift_amount"/>
		<bitfield name="INNERCONSERVATIVERASEN" pos="3" type="boolean"/>
		<bitfield name="UNK4" low="4" high="5"/>
	</bitset>

	<reg32 offset="0x8099" name="GRAS_SU_CONSERVATIVE_RAS_CNTL" type="a6xx_gras_su_conservative_ras_cntl" variants="A6XX-A7XX" usage="cmd"/>

	<reg32 offset="0x809a" name="GRAS_SU_PATH_RENDERING_CNTL">
		<bitfield name="UNK0" pos="0" type="boolean"/>
		<bitfield name="LINELENGTHEN" pos="1" type="boolean"/>
	</reg32>

	<bitset name="a6xx_gras_us_xs_siv_cntl" inline="yes">
		<bitfield name="WRITES_LAYER" pos="0" type="boolean"/>
		<bitfield name="WRITES_VIEW" pos="1" type="boolean"/>
	</bitset>
	<reg32 offset="0x809b" name="GRAS_SU_VS_SIV_CNTL" type="a6xx_gras_us_xs_siv_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x809c" name="GRAS_SU_GS_SIV_CNTL" type="a6xx_gras_us_xs_siv_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x809d" name="GRAS_SU_DS_SIV_CNTL" type="a6xx_gras_us_xs_siv_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_rast_cntl" inline="yes">
		<bitfield name="MODE" low="0" high="1" type="a6xx_polygon_mode"/>
	</bitset>

	<enum name="a6xx_sequenced_thread_dist">
		<value value="0x0" name="DIST_SCREEN_COORD"/>
		<value value="0x1" name="DIST_ALL_TO_RB0"/>
	</enum>

	<enum name="a6xx_single_prim_mode">
		<value value="0x0" name="NO_FLUSH"/>
		<doc>
			In addition to FLUSH_PER_OVERLAP, guarantee that UCHE
			and CCU don't get out of sync when fetching the previous
			value for the current pixel. With NO_FLUSH, there's the
			possibility that the flags for the current pixel are
			flushed before the data or vice-versa, leading to
			texture fetches via UCHE getting out of sync values.
			This mode should eliminate that. It's used in bypass
			mode for coherent blending
			(GL_KHR_blend_equation_advanced_coherent) as well as
			non-coherent blending.
		</doc>
		<value value="0x1" name="FLUSH_PER_OVERLAP_AND_OVERWRITE"/>
		<doc>
			Invalidate UCHE and wait for any pending work to finish
			if there was possibly an overlapping primitive prior to
			the current one. This is similar to a combination of
			GRAS_SC_CONTROL::INJECT_L2_INVALIDATE_EVENT and
			WAIT_RB_IDLE_ALL_TRI on a3xx. It's used in GMEM mode for
			coherent blending
			(GL_KHR_blend_equation_advanced_coherent).
		</doc>
		<value value="0x3" name="FLUSH_PER_OVERLAP"/>
	</enum>

	<!-- this probably has the same meaning as a3xx GRAS_SC_CONTROL::RASTER_MODE -->
	<enum name="a6xx_raster_mode">
		<value value="0x0" name="TYPE_TILED"/>
		<value value="0x1" name="TYPE_WRITER"/>
	</enum>

	<!-- I'm guessing this is the same as a3xx -->
	<enum name="a6xx_raster_direction">
		<value value="0x0" name="LR_TB"/>
		<value value="0x1" name="RL_TB"/>
		<value value="0x2" name="LR_BT"/>
		<value value="0x3" name="RB_BT"/>
	</enum>

	<bitset name="a6xx_gras_sc_cntl" inline="yes">
		<bitfield name="CCUSINGLECACHELINESIZE" low="0" high="2"/>
		<bitfield name="SINGLE_PRIM_MODE" low="3" high="4" type="a6xx_single_prim_mode"/>
		<bitfield name="RASTER_MODE" pos="5" type="a6xx_raster_mode"/>
		<bitfield name="RASTER_DIRECTION" low="6" high="7" type="a6xx_raster_direction"/>
		<bitfield name="SEQUENCED_THREAD_DISTRIBUTION" pos="8" type="a6xx_sequenced_thread_dist"/>
		<!-- CCUSINGLECACHELINESIZE is ignored unless bit 9 is set -->
		<bitfield name="UNK9" pos="9" type="boolean"/>
		<bitfield name="ROTATION" low="10" high="11" type="uint"/>
		<bitfield name="EARLYVIZOUTEN" pos="12" type="boolean"/>
	</bitset>

	<reg32 offset="0x80a0" name="GRAS_SC_CNTL" type="a6xx_gras_sc_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<enum name="a6xx_render_mode">
		<value value="0x0" name="RENDERING_PASS"/>
		<value value="0x1" name="BINNING_PASS"/>
	</enum>

	<enum name="a6xx_buffers_location">
		<value value="0" name="BUFFERS_IN_GMEM"/>
		<value value="3" name="BUFFERS_IN_SYSMEM"/>
	</enum>

	<enum name="a6xx_lrz_feedback_mask">
		<value value="0x0" name="LRZ_FEEDBACK_NONE"/>
		<value value="0x1" name="LRZ_FEEDBACK_EARLY_Z"/>
		<value value="0x2" name="LRZ_FEEDBACK_EARLY_Z_LATE_Z"/>
		<!-- We don't have a flag type and this flags combination is often used -->
		<value value="0x3" name="LRZ_FEEDBACK_EARLY_Z_OR_EARLY_Z_LATE_Z"/>
		<value value="0x4" name="LRZ_FEEDBACK_LATE_Z"/>
	</enum>

	<bitset name="a6xx_bin_cntl" inline="yes">
		<bitfield name="BINW" low="0" high="5" shr="5" type="uint"/>
		<bitfield name="BINH" low="8" high="14" shr="4" type="uint"/>
		<bitfield name="RENDER_MODE" low="18" high="20" type="a6xx_render_mode"/>
		<doc>Disable LRZ feedback writes</doc>
		<bitfield name="FORCE_LRZ_WRITE_DIS" pos="21" type="boolean"/>
		<bitfield name="BUFFERS_LOCATION" low="22" high="23" type="a6xx_buffers_location" variants="A6XX"/>
		<doc>
			Allows draws that don't have GRAS_LRZ_CNTL.LRZ_WRITE but have
			GRAS_LRZ_CNTL.ENABLE to contribute to LRZ during RENDERING pass.
			In sysmem mode GRAS_LRZ_CNTL.LRZ_WRITE is not considered.
		</doc>
		<bitfield name="LRZ_FEEDBACK_ZMODE_MASK" low="24" high="26" type="a6xx_lrz_feedback_mask"/>
		<bitfield name="FORCE_LRZ_DIS" pos="27" type="boolean"/>
	</bitset>

	<reg32 offset="0x80a1" name="GRAS_SC_BIN_CNTL" type="a6xx_bin_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_gras_sc_ras_msaa_cntl" inline="yes">
		<bitfield name="SAMPLES" low="0" high="1" type="a3xx_msaa_samples"/>
		<bitfield name="UNK2" pos="2"/>
		<bitfield name="UNK3" pos="3"/>
	</bitset>

	<reg32 offset="0x80a2" name="GRAS_SC_RAS_MSAA_CNTL" type="a6xx_gras_sc_ras_msaa_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_gras_sc_dest_msaa_cntl" inline="yes">
		<bitfield name="SAMPLES" low="0" high="1" type="a3xx_msaa_samples"/>
		<bitfield name="MSAA_DISABLE" pos="2" type="boolean"/>
	</bitset>

	<reg32 offset="0x80a3" name="GRAS_SC_DEST_MSAA_CNTL" type="a6xx_gras_sc_dest_msaa_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_msaa_sample_pos_cntl" inline="yes">
		<bitfield name="UNK0" pos="0"/>
		<bitfield name="LOCATION_ENABLE" pos="1" type="boolean"/>
	</bitset>

	<bitset name="a6xx_programmable_msaa_pos" inline="yes">
		<bitfield name="SAMPLE_0_X" low="0" high="3" radix="4" type="fixed"/>
		<bitfield name="SAMPLE_0_Y" low="4" high="7" radix="4" type="fixed"/>
		<bitfield name="SAMPLE_1_X" low="8" high="11" radix="4" type="fixed"/>
		<bitfield name="SAMPLE_1_Y" low="12" high="15" radix="4" type="fixed"/>
		<bitfield name="SAMPLE_2_X" low="16" high="19" radix="4" type="fixed"/>
		<bitfield name="SAMPLE_2_Y" low="20" high="23" radix="4" type="fixed"/>
		<bitfield name="SAMPLE_3_X" low="24" high="27" radix="4" type="fixed"/>
		<bitfield name="SAMPLE_3_Y" low="28" high="31" radix="4" type="fixed"/>
	</bitset>

	<reg32 offset="0x80a4" name="GRAS_SC_MSAA_SAMPLE_POS_CNTL" type="a6xx_msaa_sample_pos_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x80a5" name="GRAS_SC_PROGRAMMABLE_MSAA_POS_0" type="a6xx_programmable_msaa_pos" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x80a6" name="GRAS_SC_PROGRAMMABLE_MSAA_POS_1" type="a6xx_programmable_msaa_pos" variants="A6XX-A7XX" usage="rp_blit"/>

	<reg32 offset="0x80a7" name="GRAS_ROTATION_CNTL" variants="A7XX" usage="cmd"/>

	<bitset name="a6xx_screen_scissor_cntl" inline="yes">
		<bitfield name="SCISSOR_DISABLE" pos="0" type="boolean"/>
	</bitset>

	<reg32 offset="0x80af" name="GRAS_SC_SCREEN_SCISSOR_CNTL" type="a6xx_screen_scissor_cntl" variants="A6XX-A7XX" pos="0" usage="cmd"/>

	<bitset name="a6xx_scissor_xy" inline="yes">
		<bitfield name="X" low="0" high="15" type="uint"/>
		<bitfield name="Y" low="16" high="31" type="uint"/>
	</bitset>

	<array offset="0x80b0" name="GRAS_SC_SCREEN_SCISSOR" stride="2" length="16" variants="A6XX-A7XX" usage="rp_blit">
		<reg32 offset="0" name="TL" type="a6xx_scissor_xy"/>
		<reg32 offset="1" name="BR" type="a6xx_scissor_xy"/>
	</array>

	<array offset="0x80d0" name="GRAS_SC_VIEWPORT_SCISSOR" stride="2" length="16" variants="A6XX-A7XX" usage="rp_blit">
		<reg32 offset="0" name="TL" type="a6xx_scissor_xy"/>
		<reg32 offset="1" name="BR" type="a6xx_scissor_xy"/>
	</array>

	<reg32 offset="0x80f0" name="GRAS_SC_WINDOW_SCISSOR_TL" type="a6xx_reg_xy" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x80f1" name="GRAS_SC_WINDOW_SCISSOR_BR" type="a6xx_reg_xy" variants="A6XX-A7XX" usage="rp_blit"/>

	<enum name="a6xx_fsr_combiner">
		<value value="0" name="FSR_COMBINER_OP_KEEP"/>
		<value value="1" name="FSR_COMBINER_OP_REPLACE"/>
		<value value="2" name="FSR_COMBINER_OP_MIN"/>
		<value value="3" name="FSR_COMBINER_OP_MAX"/>
		<value value="4" name="FSR_COMBINER_OP_MUL"/>
	</enum>

	<bitset name="a6xx_gras_vrs_config">
		<bitfield name="PIPELINE_FSR_ENABLE" pos="0" type="boolean"/>
		<bitfield name="FRAG_SIZE_X" low="1" high="2" type="uint"/>
		<bitfield name="FRAG_SIZE_Y" low="3" high="4" type="uint"/>
		<bitfield name="COMBINER_OP_1" low="5" high="7" type="a6xx_fsr_combiner"/>
		<bitfield name="COMBINER_OP_2" low="8" high="10" type="a6xx_fsr_combiner"/>
		<bitfield name="ATTACHMENT_FSR_ENABLE" pos="13" type="boolean"/>
		<bitfield name="PRIMITIVE_FSR_ENABLE" pos="20" type="boolean"/>
	</bitset>

	<reg32 offset="0x80f4" name="GRAS_VRS_CONFIG" type="a6xx_gras_vrs_config" variants="A7XX" usage="rp_blit"/>

	<bitset name="a6xx_gras_quality_buffer_info" inline="yes">
		<bitfield name="LAYERED" pos="0" type="boolean"/>
		<bitfield name="TILE_MODE" low="1" high="2" type="a6xx_tile_mode"/>
	</bitset>

	<reg32 offset="0x80f5" name="GRAS_QUALITY_BUFFER_INFO" type="a6xx_gras_quality_buffer_info" variants="A7XX" usage="rp_blit"/>

	<bitset name="a6xx_gras_quality_buffer_dimension" inline="yes">
		<bitfield name="WIDTH" low="0" high="15" type="uint"/>
		<bitfield name="HEIGHT" low="16" high="31" type="uint"/>
	</bitset>

	<reg32 offset="0x80f6" name="GRAS_QUALITY_BUFFER_DIMENSION" type="a6xx_gras_quality_buffer_dimension" variants="A7XX" usage="rp_blit"/>

	<reg64 offset="0x80f8" name="GRAS_QUALITY_BUFFER_BASE" variants="A7XX" type="waddress" usage="rp_blit"/>

	<bitset name="a6xx_gras_quality_buffer_pitch" inline="yes">
		<bitfield name="PITCH" shr="6" low="0" high="7" type="uint"/>
		<bitfield name="ARRAY_PITCH" shr="6" low="10" high="28" type="uint"/>
	</bitset>

	<reg32 offset="0x80fa" name="GRAS_QUALITY_BUFFER_PITCH" type="a6xx_gras_quality_buffer_pitch" variants="A7XX" usage="rp_blit"/>

	<enum name="a6xx_lrz_dir_status">
		<value value="0x1" name="LRZ_DIR_LE"/>
		<value value="0x2" name="LRZ_DIR_GE"/>
		<value value="0x3" name="LRZ_DIR_INVALID"/>
	</enum>

	<bitset name="a6xx_gras_lrz_cntl" inline="yes">
		<bitfield name="ENABLE" pos="0" type="boolean"/>
		<doc>LRZ write also disabled for blend/etc.</doc>
		<bitfield name="LRZ_WRITE" pos="1" type="boolean"/>
		<doc>update MAX instead of MIN value, ie. GL_GREATER/GL_GEQUAL</doc>
		<bitfield name="GREATER" pos="2" type="boolean"/>
		<doc>
			Clears the LRZ block being touched to:
			- 0.0 if GREATER
			- 1.0 if LESS
		</doc>
		<bitfield name="FC_ENABLE" pos="3" type="boolean" variants="A6XX"/>
		<!-- set when depth-test + depth-write enabled -->
		<bitfield name="Z_WRITE_ENABLE" pos="4" type="boolean"/>
		<bitfield name="Z_BOUNDS_ENABLE" pos="5" type="boolean"/>
		<bitfield name="DIR" low="6" high="7" type="a6xx_lrz_dir_status"/>
		<doc>
			If DISABLE_ON_WRONG_DIR enabled - write new LRZ direction into
			buffer, in case of mismatched direction writes 0 (disables LRZ).
		</doc>
		<bitfield name="DIR_WRITE" pos="8" type="boolean"/>
		<doc>
			Disable LRZ based on previous direction and the current one.
			If DIR_WRITE is not enabled - there is no write to direction buffer.
		</doc>
		<bitfield name="DISABLE_ON_WRONG_DIR" pos="9" type="boolean" variants="A6XX"/>
		<bitfield name="Z_FUNC" low="11" high="13" type="adreno_compare_func" variants="A7XX-"/>
	</bitset>

	<reg32 offset="0x8100" name="GRAS_LRZ_CNTL" type="a6xx_gras_lrz_cntl" usage="rp_blit" variants="A6XX-A7XX"/>

	<enum name="a6xx_fragcoord_sample_mode">
		<value value="0" name="FRAGCOORD_CENTER"/>
		<value value="3" name="FRAGCOORD_SAMPLE"/>
	</enum>

	<bitset name="a6xx_gras_lrz_ps_input_cntl" inline="yes">
		<bitfield name="SAMPLEID" pos="0" type="boolean"/>
		<bitfield name="FRAGCOORDSAMPLEMODE" low="1" high="2" type="a6xx_fragcoord_sample_mode"/>
	</bitset>

	<reg32 offset="0x8101" name="GRAS_LRZ_PS_INPUT_CNTL" type="a6xx_gras_lrz_ps_input_cntl" usage="rp_blit" variants="A6XX-A7XX"/>

	<bitset name="a6xx_gras_lrz_mrt_buffer_info_0" inline="yes">
		<bitfield name="COLOR_FORMAT" low="0" high="7" type="a6xx_format"/>
	</bitset>

	<reg32 offset="0x8102" name="GRAS_LRZ_MRT_BUFFER_INFO_0" type="a6xx_gras_lrz_mrt_buffer_info_0" usage="rp_blit" variants="A6XX-A7XX"/>

	<reg64 offset="0x8103" name="GRAS_LRZ_BUFFER_BASE" align="256" type="waddress" usage="rp_blit" variants="A6XX-A7XX"/>

	<bitset name="a6xx_gras_lrz_buffer_pitch" inline="yes">
		<bitfield name="PITCH" low="0" high="7" shr="5" type="uint"/>
		<bitfield name="ARRAY_PITCH" low="10" high="28" shr="8" type="uint"/>
	</bitset>

	<reg32 offset="0x8105" name="GRAS_LRZ_BUFFER_PITCH" type="a6xx_gras_lrz_buffer_pitch" usage="rp_blit" variants="A6XX-A7XX"/>

	<!--
	The LRZ "fast clear" buffer is initialized to zero's by blob, and
	read/written when GRAS_LRZ_CNTL.FC_ENABLE (b3) is set.  It appears
	to store 1b/block.  It appears that '0' means block has original
	depth clear value, and '1' means that the corresponding block in
	LRZ has been modified.  Ignoring alignment/padding, the size is
	given by the formula:

		// calculate LRZ size from depth size:
		if (nr_samples == 4) {
			width *= 2;
			height *= 2;
		} else if (nr_samples == 2) {
			height *= 2;
		}

		lrz_width = div_round_up(width, 8);
		lrz_heigh = div_round_up(height, 8);

		// calculate # of blocks:
		nblocksx = div_round_up(lrz_width, 16);
		nblocksy = div_round_up(lrz_height, 4);

		// fast-clear buffer is 1bit/block:
		fc_sz = div_round_up(nblocksx * nblocksy, 8);

	In practice the blob seems to switch off FC_ENABLE once the size
	increases beyond 1 page.  Not sure if that is an actual limit or
	not.
	 -->
	<reg64 offset="0x8106" name="GRAS_LRZ_FAST_CLEAR_BUFFER_BASE" align="64" type="waddress" usage="rp_blit"/>
	<reg32 offset="0x8109" name="GRAS_LRZ_PS_SAMPLEFREQ_CNTL" usage="rp_blit">
		<bitfield name="PER_SAMP_MODE" pos="0" type="boolean"/>
	</reg32>
	<!--
	LRZ buffer represents a single array layer + mip level, and there is
	a single buffer per depth image. Thus to reuse LRZ between renderpasses
	it is necessary to track the depth view used in the past renderpass, which
	GRAS_LRZ_VIEW_INFO is for.
	GRAS_LRZ_CNTL checks if current value of GRAS_LRZ_VIEW_INFO is equal to
	the value stored in the LRZ buffer, if not - LRZ is disabled.
	-->
	<reg32 offset="0x810a" name="GRAS_LRZ_VIEW_INFO" usage="cmd">
		<bitfield name="BASE_LAYER" low="0" high="10" type="uint"/>
		<bitfield name="LAYER_COUNT" low="16" high="26" type="uint"/>
		<bitfield name="BASE_MIP_LEVEL" low="28" high="31" type="uint"/>
	</reg32>

	<reg32 offset="0x810b" name="GRAS_LRZ_CNTL2" variants="A7XX-" usage="rp_blit">
		<bitfield name="DISABLE_ON_WRONG_DIR" pos="0" type="boolean"/>
		<bitfield name="FC_ENABLE" pos="1" type="boolean"/>
	</reg32>

	<!-- 0x810c-0x810f invalid -->

	<reg32 offset="0x8110" name="GRAS_MODE_CNTL" low="0" high="1" variants="A6XX-A7XX" usage="cmd"/>

	<!-- A bit tentative but it's a color and it is followed by LRZ_CLEAR -->
	<reg32 offset="0x8111" name="GRAS_LRZ_DEPTH_CLEAR" type="float" variants="A7XX"/>

	<bitset name="a6xx_gras_lrz_depth_buffer_info" inline="yes">
		<bitfield name="DEPTH_FORMAT" low="0" high="2" type="a6xx_depth_format"/>
		<bitfield name="UNK3" pos="3"/>
	</bitset>

	<reg32 offset="0x8113" name="GRAS_LRZ_DEPTH_BUFFER_INFO" type="a6xx_gras_lrz_depth_buffer_info" variants="A7XX" usage="rp_blit"/>

	<doc>LUT used to convert quality buffer values to HW shading rate values. An array of 4-bit values.</doc>
	<array offset="0x8120" name="GRAS_LRZ_QUALITY_LOOKUP_TABLE" variants="A7XX-" stride="1" length="2"/>

	<!-- 0x8112-0x83ff invalid -->

	<enum name="a6xx_rotation">
		<value value="0x0" name="ROTATE_0"/>
		<value value="0x1" name="ROTATE_90"/>
		<value value="0x2" name="ROTATE_180"/>
		<value value="0x3" name="ROTATE_270"/>
		<value value="0x4" name="ROTATE_HFLIP"/>
		<value value="0x5" name="ROTATE_VFLIP"/>
	</enum>

	<bitset name="a6xx_a2d_bit_cntl" inline="yes">
		<bitfield name="ROTATE" low="0" high="2" type="a6xx_rotation"/>
		<bitfield name="OVERWRITEEN" pos="3" type="boolean"/>
		<bitfield name="UNK4" low="4" high="6"/>
		<bitfield name="SOLID_COLOR" pos="7" type="boolean"/>
		<bitfield name="COLOR_FORMAT" low="8" high="15" type="a6xx_format"/>
		<bitfield name="SCISSOR" pos="16" type="boolean"/>
		<bitfield name="UNK17" low="17" high="18"/>
		<!-- required when blitting D24S8/D24X8 -->
		<bitfield name="D24S8" pos="19" type="boolean"/>
		<!-- some sort of channel mask, disabled channels are set to zero ? -->
		<bitfield name="MASK" low="20" high="23"/>
		<bitfield name="IFMT" low="24" high="26" type="a6xx_2d_ifmt"/>
		<bitfield name="UNK27" pos="27" type="boolean"/>
		<bitfield name="UNK28" pos="28" type="boolean"/>
		<bitfield name="RASTER_MODE" pos="29" type="a6xx_raster_mode"/>
		<bitfield name="COPY" pos="30" type="boolean" variants="A7XX-"/>
	</bitset>

	<reg32 offset="0x8400" name="GRAS_A2D_BLT_CNTL" type="a6xx_a2d_bit_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<!-- note: the low 8 bits for src coords are valid, probably fixed point
	     it would be a bit weird though, since we subtract 1 from BR coords
	     apparently signed, gallium driver uses negative coords and it works?
	 -->
	<reg32 offset="0x8401" name="GRAS_A2D_SRC_XMIN" low="8" high="24" type="int" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x8402" name="GRAS_A2D_SRC_XMAX" low="8" high="24" type="int" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x8403" name="GRAS_A2D_SRC_YMIN" low="8" high="24" type="int" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x8404" name="GRAS_A2D_SRC_YMAX" low="8" high="24" type="int" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x8405" name="GRAS_A2D_DEST_TL" type="a6xx_reg_xy" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x8406" name="GRAS_A2D_DEST_BR" type="a6xx_reg_xy" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x8407" name="GRAS_2D_UNKNOWN_8407" low="0" high="31"/>
	<reg32 offset="0x8408" name="GRAS_2D_UNKNOWN_8408" low="0" high="31"/>
	<reg32 offset="0x8409" name="GRAS_2D_UNKNOWN_8409" low="0" high="31"/>
	<reg32 offset="0x840a" name="GRAS_A2D_SCISSOR_TL" type="a6xx_reg_xy" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x840b" name="GRAS_A2D_SCISSOR_BR" type="a6xx_reg_xy" variants="A6XX-A7XX" usage="rp_blit"/>

	<!-- always 0x880 ? (and 0 in a640/a650 traces?) -->
	<reg32 offset="0x8600" name="GRAS_DBG_ECO_CNTL" usage="cmd">
		<bitfield name="UNK7" pos="7" type="boolean"/>
		<bitfield name="LRZCACHELOCKDIS" pos="11" type="boolean"/>
	</reg32>
	<reg32 offset="0x8601" name="GRAS_ADDR_MODE_CNTL" pos="0" type="a5xx_address_mode"/>
	<reg32 offset="0x8602" name="GRAS_NC_MODE_CNTL" variants="A7XX-"/>
	<array offset="0x8610" name="GRAS_PERFCTR_TSE_SEL" stride="1" length="4"/>
	<array offset="0x8614" name="GRAS_PERFCTR_RAS_SEL" stride="1" length="4"/>
	<array offset="0x8618" name="GRAS_PERFCTR_LRZ_SEL" stride="1" length="4"/>

	<!-- note 0x8620-0x87ff are not all invalid
	(in particular, 0x8631/0x8632 have 0x3fff3fff mask and would be xy coords)
	-->

	<!-- same as GRAS_BIN_CONTROL, but without bit 27: -->
	<reg32 offset="0x8800" name="RB_CNTL" variants="A6XX-A7XX" type="a6xx_bin_cntl" usage="rp_blit"/>

	<reg32 offset="0x8801" name="RB_RENDER_CNTL" variants="A6XX" usage="rp_blit">
		<bitfield name="CCUSINGLECACHELINESIZE" low="3" high="5"/>
		<bitfield name="EARLYVIZOUTEN" pos="6" type="boolean"/>
		<bitfield name="FS_DISABLE" pos="7" type="boolean"/>
		<bitfield name="UNK8" low="8" high="10"/>
		<bitfield name="RASTER_MODE" pos="8" type="a6xx_raster_mode"/>
		<bitfield name="RASTER_DIRECTION" low="9" high="10" type="a6xx_raster_direction"/>
		<bitfield name="CONSERVATIVERASEN" pos="11" type="boolean"/>
		<bitfield name="INNERCONSERVATIVERASEN" pos="12" type="boolean"/>
		<!-- bit seems to be set whenever depth buffer enabled: -->
		<bitfield name="FLAG_DEPTH" pos="14" type="boolean"/>
		<!-- bitmask of MRTs using UBWC flag buffer: -->
		<bitfield name="FLAG_MRTS" low="16" high="23"/>
	</reg32>
	<reg32 offset="0x8801" name="RB_RENDER_CNTL" variants="A7XX-" usage="rp_blit">
		<bitfield name="EARLYVIZOUTEN" pos="6" type="boolean"/>
		<bitfield name="FS_DISABLE" pos="7" type="boolean"/>
		<bitfield name="RASTER_MODE" pos="8" type="a6xx_raster_mode"/>
		<bitfield name="RASTER_DIRECTION" low="9" high="10" type="a6xx_raster_direction"/>
		<bitfield name="CONSERVATIVERASEN" pos="11" type="boolean"/>
		<bitfield name="INNERCONSERVATIVERASEN" pos="12" type="boolean"/>
	</reg32>

	<reg32 offset="0x8802" name="RB_RAS_MSAA_CNTL" usage="rp_blit">
		<bitfield name="SAMPLES" low="0" high="1" type="a3xx_msaa_samples"/>
		<bitfield name="UNK2" pos="2"/>
		<bitfield name="UNK3" pos="3"/>
	</reg32>
	<reg32 offset="0x8803" name="RB_DEST_MSAA_CNTL" usage="rp_blit">
		<bitfield name="SAMPLES" low="0" high="1" type="a3xx_msaa_samples"/>
		<bitfield name="MSAA_DISABLE" pos="2" type="boolean"/>
	</reg32>

	<reg32 offset="0x8804" name="RB_MSAA_SAMPLE_POS_CNTL" type="a6xx_msaa_sample_pos_cntl" usage="rp_blit"/>
	<reg32 offset="0x8805" name="RB_PROGRAMMABLE_MSAA_POS_0" type="a6xx_programmable_msaa_pos" usage="rp_blit"/>
	<reg32 offset="0x8806" name="RB_PROGRAMMABLE_MSAA_POS_1" type="a6xx_programmable_msaa_pos" usage="rp_blit"/>
	<!-- 0x8807-0x8808 invalid -->
	<!--
	note: maybe not actually called RB_RENDER_CONTROLn (since RB_RENDER_CNTL
	name comes from kernel and is probably right)
	 -->
	<reg32 offset="0x8809" name="RB_INTERP_CNTL" usage="rp_blit">
		<!-- see also GRAS_CL_INTERP_CNTL -->
		<bitfield name="IJ_PERSP_PIXEL" pos="0" type="boolean"/>
		<bitfield name="IJ_PERSP_CENTROID" pos="1" type="boolean"/>
		<bitfield name="IJ_PERSP_SAMPLE" pos="2" type="boolean"/>
		<bitfield name="IJ_LINEAR_PIXEL" pos="3" type="boolean"/>
		<bitfield name="IJ_LINEAR_CENTROID" pos="4" type="boolean"/>
		<bitfield name="IJ_LINEAR_SAMPLE" pos="5" type="boolean"/>
		<bitfield name="COORD_MASK" low="6" high="9" type="hex"/>
		<bitfield name="UNK10" pos="10" type="boolean"/>
	</reg32>
	<reg32 offset="0x880a" name="RB_PS_INPUT_CNTL" usage="rp_blit">
		<!-- enable bits for various FS sysvalue regs: -->
		<bitfield name="SAMPLEMASK" pos="0" type="boolean"/>
		<bitfield name="POSTDEPTHCOVERAGE" pos="1" type="boolean"/>
		<bitfield name="FACENESS" pos="2" type="boolean"/>
		<bitfield name="SAMPLEID" pos="3" type="boolean"/>
		<bitfield name="FRAGCOORDSAMPLEMODE" low="4" high="5" type="a6xx_fragcoord_sample_mode"/>
		<bitfield name="CENTERRHW" pos="6" type="boolean"/>
		<bitfield name="LINELENGTHEN" pos="7" type="boolean"/>
		<bitfield name="FOVEATION" pos="8" type="boolean"/>
	</reg32>

	<reg32 offset="0x880b" name="RB_PS_OUTPUT_CNTL" usage="rp_blit">
		<bitfield name="DUAL_COLOR_IN_ENABLE" pos="0" type="boolean"/>
		<bitfield name="FRAG_WRITES_Z" pos="1" type="boolean"/>
		<bitfield name="FRAG_WRITES_SAMPMASK" pos="2" type="boolean"/>
		<bitfield name="FRAG_WRITES_STENCILREF" pos="3" type="boolean"/>
	</reg32>
	<reg32 offset="0x880c" name="RB_PS_MRT_CNTL" usage="rp_blit">
		<bitfield name="MRT" low="0" high="3" type="uint"/>
	</reg32>
	<reg32 offset="0x880d" name="RB_PS_OUTPUT_MASK" usage="rp_blit">
		<bitfield name="RT0" low="0" high="3"/>
		<bitfield name="RT1" low="4" high="7"/>
		<bitfield name="RT2" low="8" high="11"/>
		<bitfield name="RT3" low="12" high="15"/>
		<bitfield name="RT4" low="16" high="19"/>
		<bitfield name="RT5" low="20" high="23"/>
		<bitfield name="RT6" low="24" high="27"/>
		<bitfield name="RT7" low="28" high="31"/>
	</reg32>
	<reg32 offset="0x880e" name="RB_DITHER_CNTL" usage="cmd">
		<bitfield name="DITHER_MODE_MRT0" low="0"  high="1"  type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT1" low="2"  high="3"  type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT2" low="4"  high="5"  type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT3" low="6"  high="7"  type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT4" low="8"  high="9"  type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT5" low="10" high="11" type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT6" low="12" high="13" type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT7" low="14" high="15" type="adreno_rb_dither_mode"/>
	</reg32>
	<reg32 offset="0x880f" name="RB_SRGB_CNTL" usage="rp_blit">
		<!-- Same as SP_SRGB_CNTL -->
		<bitfield name="SRGB_MRT0" pos="0" type="boolean"/>
		<bitfield name="SRGB_MRT1" pos="1" type="boolean"/>
		<bitfield name="SRGB_MRT2" pos="2" type="boolean"/>
		<bitfield name="SRGB_MRT3" pos="3" type="boolean"/>
		<bitfield name="SRGB_MRT4" pos="4" type="boolean"/>
		<bitfield name="SRGB_MRT5" pos="5" type="boolean"/>
		<bitfield name="SRGB_MRT6" pos="6" type="boolean"/>
		<bitfield name="SRGB_MRT7" pos="7" type="boolean"/>
	</reg32>

	<reg32 offset="0x8810" name="RB_PS_SAMPLEFREQ_CNTL" usage="rp_blit">
		<bitfield name="PER_SAMP_MODE" pos="0" type="boolean"/>
	</reg32>
	<reg32 offset="0x8811" name="RB_UNKNOWN_8811" low="4" high="6" usage="cmd"/>
	<reg32 offset="0x8812" name="RB_UNKNOWN_8812" variants="A7XX-" usage="rp_blit"/>
	<!-- 0x8813-0x8817 invalid -->
	<!-- always 0x0 ? -->
	<reg32 offset="0x8818" name="RB_UNKNOWN_8818" low="0" high="6" usage="cmd"/>
	<!-- 0x8819-0x881e all 32 bits -->
	<reg32 offset="0x8819" name="RB_UNKNOWN_8819" usage="cmd"/>
	<reg32 offset="0x881a" name="RB_UNKNOWN_881A" usage="cmd"/>
	<reg32 offset="0x881b" name="RB_UNKNOWN_881B" usage="cmd"/>
	<reg32 offset="0x881c" name="RB_UNKNOWN_881C" usage="cmd"/>
	<reg32 offset="0x881d" name="RB_UNKNOWN_881D" usage="cmd"/>
	<reg32 offset="0x881e" name="RB_UNKNOWN_881E" usage="cmd"/>
	<!-- 0x881f invalid -->
	<array offset="0x8820" name="RB_MRT" stride="8" length="8" usage="rp_blit">
		<reg32 offset="0x0" name="CONTROL">
			<bitfield name="BLEND" pos="0" type="boolean"/>
			<bitfield name="BLEND2" pos="1" type="boolean"/>
			<bitfield name="ROP_ENABLE" pos="2" type="boolean"/>
			<bitfield name="ROP_CODE" low="3" high="6" type="a3xx_rop_code"/>
			<bitfield name="COMPONENT_ENABLE" low="7" high="10" type="hex"/>
		</reg32>
		<reg32 offset="0x1" name="BLEND_CONTROL">
			<bitfield name="RGB_SRC_FACTOR" low="0" high="4" type="adreno_rb_blend_factor"/>
			<bitfield name="RGB_BLEND_OPCODE" low="5" high="7" type="a3xx_rb_blend_opcode"/>
			<bitfield name="RGB_DEST_FACTOR" low="8" high="12" type="adreno_rb_blend_factor"/>
			<bitfield name="ALPHA_SRC_FACTOR" low="16" high="20" type="adreno_rb_blend_factor"/>
			<bitfield name="ALPHA_BLEND_OPCODE" low="21" high="23" type="a3xx_rb_blend_opcode"/>
			<bitfield name="ALPHA_DEST_FACTOR" low="24" high="28" type="adreno_rb_blend_factor"/>
		</reg32>
		<reg32 offset="0x2" name="BUF_INFO" variants="A6XX">
			<bitfield name="COLOR_FORMAT" low="0" high="7" type="a6xx_format"/>
			<bitfield name="COLOR_TILE_MODE" low="8" high="9" type="a6xx_tile_mode"/>
			<bitfield name="UNK10" pos="10"/>
			<bitfield name="COLOR_SWAP" low="13" high="14" type="a3xx_color_swap"/>
		</reg32>
		<reg32 offset="0x2" name="BUF_INFO" variants="A7XX-">
			<bitfield name="COLOR_FORMAT" low="0" high="7" type="a6xx_format"/>
			<bitfield name="COLOR_TILE_MODE" low="8" high="9" type="a6xx_tile_mode"/>
			<bitfield name="UNK10" pos="10"/>
			<bitfield name="LOSSLESSCOMPEN" pos="11" type="boolean"/>
			<bitfield name="COLOR_SWAP" low="13" high="14" type="a3xx_color_swap"/>
			<bitfield name="MUTABLEEN" pos="16" type="boolean" variants="A7XX-"/>
		</reg32>
		<!--
		at least in gmem, things seem to be aligned to pitch of 64..
		maybe an artifact of tiled format used in gmem?
		 -->
		<reg32 offset="0x3" name="PITCH" shr="6" high="15" type="uint"/>
		<reg32 offset="0x4" name="ARRAY_PITCH" shr="6" high="28" type="uint"/>
		<!--
		Compared to a5xx and before, we configure both a GMEM base and
		external base.  Not sure if this is to facilitate GMEM save/
		restore for context switch, or just to simplify state setup to
		not have to care about GMEM vs BYPASS mode.
		 -->
		<!-- maybe something in low bits since alignment of 1 doesn't make sense? -->
		<reg64 offset="0x5" name="BASE" type="waddress" align="1"/>

		<reg32 offset="0x7" name="BASE_GMEM" low="12" high="31" shr="12"/>
	</array>

	<reg32 offset="0x8860" name="RB_BLEND_CONSTANT_RED_FP32" type="float" usage="rp_blit"/>
	<reg32 offset="0x8861" name="RB_BLEND_CONSTANT_GREEN_FP32" type="float" usage="rp_blit"/>
	<reg32 offset="0x8862" name="RB_BLEND_CONSTANT_BLUE_FP32" type="float" usage="rp_blit"/>
	<reg32 offset="0x8863" name="RB_BLEND_CONSTANT_ALPHA_FP32" type="float" usage="rp_blit"/>
	<reg32 offset="0x8864" name="RB_ALPHA_TEST_CNTL" usage="cmd">
		<bitfield name="ALPHA_REF" low="0" high="7" type="hex"/>
		<bitfield name="ALPHA_TEST" pos="8" type="boolean"/>
		<bitfield name="ALPHA_TEST_FUNC" low="9" high="11" type="adreno_compare_func"/>
	</reg32>
	<reg32 offset="0x8865" name="RB_BLEND_CNTL" usage="rp_blit">
		<!-- per-mrt enable bit -->
		<bitfield name="BLEND_READS_DEST" low="0" high="7"/>
		<bitfield name="INDEPENDENT_BLEND" pos="8" type="boolean"/>
		<bitfield name="DUAL_COLOR_IN_ENABLE" pos="9" type="boolean"/>
		<bitfield name="ALPHA_TO_COVERAGE" pos="10" type="boolean"/>
		<bitfield name="ALPHA_TO_ONE" pos="11" type="boolean"/>
		<bitfield name="SAMPLE_MASK" low="16" high="31"/>
	</reg32>
	<!-- 0x8866-0x886f invalid -->
	<reg32 offset="0x8870" name="RB_DEPTH_PLANE_CNTL" type="a6xx_depth_plane_cntl" usage="rp_blit"/>

	<reg32 offset="0x8871" name="RB_DEPTH_CNTL" usage="rp_blit">
		<bitfield name="Z_TEST_ENABLE" pos="0" type="boolean"/>
		<bitfield name="Z_WRITE_ENABLE" pos="1" type="boolean"/>
		<bitfield name="ZFUNC" low="2" high="4" type="adreno_compare_func"/>
		<bitfield name="Z_CLAMP_ENABLE" pos="5" type="boolean"/>
		<doc>
		Z_READ_ENABLE bit is set for zfunc other than GL_ALWAYS or GL_NEVER
		also set when Z_BOUNDS_ENABLE is set
		</doc>
		<bitfield name="Z_READ_ENABLE" pos="6" type="boolean"/>
		<bitfield name="Z_BOUNDS_ENABLE" pos="7" type="boolean"/>
	</reg32>

	<!-- duplicates GRAS_SU_DEPTH_BUFFER_INFO: -->
	<reg32 offset="0x8872" name="RB_DEPTH_BUFFER_INFO" variants="A6XX" type="a6xx_depth_buffer_info" usage="rp_blit"/>
	<!-- first 4 bits duplicates GRAS_SU_DEPTH_BUFFER_INFO -->
	<reg32 offset="0x8872" name="RB_DEPTH_BUFFER_INFO" variants="A7XX-" usage="rp_blit">
		<bitfield name="DEPTH_FORMAT" low="0" high="2" type="a6xx_depth_format"/>
		<bitfield name="UNK3" low="3" high="4"/>
		<bitfield name="TILEMODE" low="5" high="6" type="a6xx_tile_mode"/>
		<bitfield name="LOSSLESSCOMPEN" pos="7" type="boolean"/>
	</reg32>

	<reg32 offset="0x8873" name="RB_DEPTH_BUFFER_PITCH" low="0" high="13" shr="6" type="uint" usage="rp_blit"/>
	<reg32 offset="0x8874" name="RB_DEPTH_BUFFER_ARRAY_PITCH" low="0" high="27" shr="6" type="uint" usage="rp_blit"/>
	<reg64 offset="0x8875" name="RB_DEPTH_BUFFER_BASE" type="waddress" align="64" usage="rp_blit"/>
	<reg32 offset="0x8877" name="RB_DEPTH_GMEM_BASE" low="12" high="31" shr="12" usage="rp_blit"/>

	<reg32 offset="0x8878" name="RB_DEPTH_BOUND_MIN" type="float" usage="rp_blit"/>
	<reg32 offset="0x8879" name="RB_DEPTH_BOUND_MAX" type="float" usage="rp_blit"/>
	<!-- 0x887a-0x887f invalid -->
	<reg32 offset="0x8880" name="RB_STENCIL_CNTL" usage="rp_blit">
		<bitfield name="STENCIL_ENABLE" pos="0" type="boolean"/>
		<bitfield name="STENCIL_ENABLE_BF" pos="1" type="boolean"/>
		<!--
			set for stencil operations that require read from stencil
			buffer, but not for example for stencil clear (which does
			not require read).. so guessing this is analogous to
			READ_DEST_ENABLE for color buffer..
		 -->
		<bitfield name="STENCIL_READ" pos="2" type="boolean"/>
		<bitfield name="FUNC" low="8" high="10" type="adreno_compare_func"/>
		<bitfield name="FAIL" low="11" high="13" type="adreno_stencil_op"/>
		<bitfield name="ZPASS" low="14" high="16" type="adreno_stencil_op"/>
		<bitfield name="ZFAIL" low="17" high="19" type="adreno_stencil_op"/>
		<bitfield name="FUNC_BF" low="20" high="22" type="adreno_compare_func"/>
		<bitfield name="FAIL_BF" low="23" high="25" type="adreno_stencil_op"/>
		<bitfield name="ZPASS_BF" low="26" high="28" type="adreno_stencil_op"/>
		<bitfield name="ZFAIL_BF" low="29" high="31" type="adreno_stencil_op"/>
	</reg32>

	<reg32 offset="0x8881" name="RB_STENCIL_BUFFER_INFO" variants="A6XX" usage="rp_blit">
		<bitfield name="SEPARATE_STENCIL" pos="0" type="boolean"/>
		<bitfield name="UNK1" pos="1" type="boolean"/>
	</reg32>
	<reg32 offset="0x8881" name="RB_STENCIL_BUFFER_INFO" variants="A7XX-" usage="rp_blit">
		<bitfield name="SEPARATE_STENCIL" pos="0" type="boolean"/>
		<bitfield name="UNK1" pos="1" type="boolean"/>
		<bitfield name="TILEMODE" low="2" high="3" type="a6xx_tile_mode"/>
	</reg32>
	<reg32 offset="0x8882" name="RB_STENCIL_BUFFER_PITCH" low="0" high="11" shr="6" type="uint" usage="rp_blit"/>
	<reg32 offset="0x8883" name="RB_STENCIL_BUFFER_ARRAY_PITCH" low="0" high="23" shr="6" type="uint" usage="rp_blit"/>
	<reg64 offset="0x8884" name="RB_STENCIL_BUFFER_BASE" type="waddress" align="64" usage="rp_blit"/>
	<reg32 offset="0x8886" name="RB_STENCIL_GMEM_BASE" low="12" high="31" shr="12" usage="rp_blit"/>
	<reg32 offset="0x8887" name="RB_STENCIL_REF_CNTL" usage="rp_blit">
		<bitfield name="REF" low="0" high="7"/>
		<bitfield name="BFREF" low="8" high="15"/>
	</reg32>
	<reg32 offset="0x8888" name="RB_STENCIL_MASK" usage="rp_blit">
		<bitfield name="MASK" low="0" high="7"/>
		<bitfield name="BFMASK" low="8" high="15"/>
	</reg32>
	<reg32 offset="0x8889" name="RB_STENCIL_WRITE_MASK" usage="rp_blit">
		<bitfield name="WRMASK" low="0" high="7"/>
		<bitfield name="BFWRMASK" low="8" high="15"/>
	</reg32>
	<!-- 0x888a-0x888f invalid -->
	<reg32 offset="0x8890" name="RB_WINDOW_OFFSET" type="a6xx_reg_xy" usage="rp_blit"/>
	<reg32 offset="0x8891" name="RB_SAMPLE_COUNTER_CNTL" usage="cmd">
		<bitfield name="DISABLE" pos="0" type="boolean"/>
		<bitfield name="COPY" pos="1" type="boolean"/>
	</reg32>
	<!-- 0x8892-0x8897 invalid -->
	<reg32 offset="0x8898" name="RB_LRZ_CNTL" usage="rp_blit">
		<bitfield name="ENABLE" pos="0" type="boolean"/>
	</reg32>
	<reg32 offset="0x8899" name="RB_UNKNOWN_8899" variants="A7XX-" usage="cmd"/>
	<!-- 0x8899-0x88bf invalid -->
	<!-- clamps depth value for depth test/write -->
	<reg32 offset="0x88c0" name="RB_VIEWPORT_ZCLAMP_MIN" type="float" usage="rp_blit" variants="A6XX-A7XX"/>
	<reg32 offset="0x88c1" name="RB_VIEWPORT_ZCLAMP_MAX" type="float" usage="rp_blit" variants="A6XX-A7XX"/>

	<!-- 0x88c2-0x88cf invalid-->
	<reg32 offset="0x88d0" name="RB_RESOLVE_CNTL_0" usage="rp_blit">
		<bitfield name="UNK0" low="0" high="12"/>
		<bitfield name="UNK16" low="16" high="26"/>
	</reg32>
	<reg32 offset="0x88d1" name="RB_RESOLVE_CNTL_1" type="a6xx_reg_xy" usage="rp_blit"/>
	<reg32 offset="0x88d2" name="RB_RESOLVE_CNTL_2" type="a6xx_reg_xy" usage="rp_blit"/>
	<!-- weird to duplicate other regs from same block?? -->
	<reg32 offset="0x88d3" name="RB_RESOLVE_CNTL_3" variants="A6XX-A7XX" usage="rp_blit">
		<bitfield name="BINW" low="0" high="5" shr="5" type="uint"/>
		<bitfield name="BINH" low="8" high="14" shr="4" type="uint"/>
	</reg32>
	<reg32 offset="0x88d4" name="RB_RESOLVE_WINDOW_OFFSET" type="a6xx_reg_xy" usage="rp_blit"/>
	<reg32 offset="0x88d5" name="RB_RESOLVE_GMEM_BUFFER_INFO" usage="rp_blit">
		<bitfield name="SAMPLES" low="3" high="4" type="a3xx_msaa_samples"/>
	</reg32>
	<reg32 offset="0x88d6" name="RB_RESOLVE_GMEM_BUFFER_BASE" low="12" high="31" shr="12" usage="rp_blit"/>
	<!-- s/DST_FORMAT/DST_INFO/ probably: -->
	<reg32 offset="0x88d7" name="RB_RESOLVE_SYSTEM_BUFFER_INFO" usage="rp_blit">
		<bitfield name="TILE_MODE" low="0" high="1" type="a6xx_tile_mode"/>
		<bitfield name="FLAGS" pos="2" type="boolean"/>
		<bitfield name="SAMPLES" low="3" high="4" type="a3xx_msaa_samples"/>
		<bitfield name="COLOR_SWAP" low="5" high="6" type="a3xx_color_swap"/>
		<bitfield name="COLOR_FORMAT" low="7" high="14" type="a6xx_format"/>
		<bitfield name="UNK15" pos="15" type="boolean"/>
		<bitfield name="MUTABLEEN" pos="16" type="boolean" variants="A7XX-"/>
	</reg32>
	<reg64 offset="0x88d8" name="RB_RESOLVE_SYSTEM_BUFFER_BASE" type="waddress" align="64" usage="rp_blit"/>
	<reg32 offset="0x88da" name="RB_RESOLVE_SYSTEM_BUFFER_PITCH" low="0" high="15" shr="6" type="uint" usage="rp_blit"/>
	<!-- array-pitch is size of layer -->
	<reg32 offset="0x88db" name="RB_RESOLVE_SYSTEM_BUFFER_ARRAY_PITCH" low="0" high="28" shr="6" type="uint" usage="rp_blit"/>
	<reg64 offset="0x88dc" name="RB_RESOLVE_SYSTEM_FLAG_BUFFER_BASE" type="waddress" align="64" usage="rp_blit"/>

	<bitset name="a6xx_flag_buffer_pitch" inline="yes">
		<bitfield name="PITCH" low="0" high="10" shr="6" type="uint"/>
		<bitfield name="ARRAY_PITCH" low="11" high="28" shr="7" type="uint"/>
	</bitset>

	<reg32 offset="0x88de" name="RB_RESOLVE_SYSTEM_FLAG_BUFFER_PITCH" type="a6xx_flag_buffer_pitch" usage="rp_blit"/>

	<reg32 offset="0x88df" name="RB_RESOLVE_CLEAR_COLOR_DW0" usage="rp_blit"/>
	<reg32 offset="0x88e0" name="RB_RESOLVE_CLEAR_COLOR_DW1" usage="rp_blit"/>
	<reg32 offset="0x88e1" name="RB_RESOLVE_CLEAR_COLOR_DW2" usage="rp_blit"/>
	<reg32 offset="0x88e2" name="RB_RESOLVE_CLEAR_COLOR_DW3" usage="rp_blit"/>

	<enum name="a6xx_blit_event_type">
		<value value="0x0" name="BLIT_EVENT_STORE"/>
		<value value="0x1" name="BLIT_EVENT_STORE_AND_CLEAR"/>
		<value value="0x2" name="BLIT_EVENT_CLEAR"/>
		<value value="0x3" name="BLIT_EVENT_LOAD"/>
	</enum>

	<!-- seems somewhat similar to what we called RB_CLEAR_CNTL on a5xx: -->
	<reg32 offset="0x88e3" name="RB_RESOLVE_OPERATION" usage="rp_blit">
		<bitfield name="TYPE" low="0" high="1" type="a6xx_blit_event_type"/>
		<bitfield name="SAMPLE_0" pos="2" type="boolean"/> <!-- takes sample 0 instead of averaging -->
		<bitfield name="DEPTH" pos="3" type="boolean"/> <!-- z16/z32/z24s8/x24x8 clear or resolve? -->
		<doc>
			For clearing depth/stencil
				1 - depth
				2 - stencil
				3 - depth+stencil
			For clearing color buffer:
				then probably a component mask, I always see 0xf
		</doc>
		<bitfield name="CLEAR_MASK" low="4" high="7"/>
		<!-- set when this is the last resolve on a650+ -->
		<bitfield name="LAST" low="8" high="9"/>
		<!--
			a618 GLES: color render target number being resolved for CCU_RESOLVE, 0x8 for depth, 0x9 for separate stencil.
			a618 VK: 0x8 for depth CCU_RESOLVE, 0x9 for separate stencil, 0 otherwise.
			a7xx VK: 0x8 for depth, 0x9 for separate stencil, 0x0 to 0x7 used for concurrent resolves of color render
			targets inside a given resolve group.
		 -->
		<bitfield name="BUFFER_ID" low="12" high="15"/>
	</reg32>

	<enum name="a7xx_blit_clear_mode">
		<value value="0x0" name="CLEAR_MODE_SYSMEM"/>
		<value value="0x1" name="CLEAR_MODE_GMEM"/>
	</enum>
	<reg32 offset="0x88e4" name="RB_CLEAR_TARGET" variants="A7XX-" usage="rp_blit">
			<bitfield name="CLEAR_MODE" pos="0" type="a7xx_blit_clear_mode"/>
	</reg32>

	<enum name="a6xx_ccu_cache_size">
		<value value="0x0" name="CCU_CACHE_SIZE_FULL"/>
		<value value="0x1" name="CCU_CACHE_SIZE_HALF"/>
		<value value="0x2" name="CCU_CACHE_SIZE_QUARTER"/>
		<value value="0x3" name="CCU_CACHE_SIZE_EIGHTH"/>
	</enum>
	<reg32 offset="0x88e5" name="RB_CCU_CACHE_CNTL" variants="A7XX-" usage="cmd">
		<bitfield name="DEPTH_OFFSET_HI" pos="0" type="hex"/>
		<bitfield name="COLOR_OFFSET_HI" pos="2" type="hex"/>
		<bitfield name="DEPTH_CACHE_SIZE" low="10" high="11" type="a6xx_ccu_cache_size"/>
		<!-- GMEM offset of CCU depth cache -->
		<bitfield name="DEPTH_OFFSET" low="12" high="20" shr="12" type="hex"/>
		<bitfield name="COLOR_CACHE_SIZE" low="21" high="22" type="a6xx_ccu_cache_size"/>
		<!-- GMEM offset of CCU color cache
			for GMEM rendering, we set it to GMEM size minus the minimum
			CCU color cache size. CCU color cache will be needed in some
			resolve cases, and in those cases we need to reserve the end
			of GMEM for color cache.
		-->
		<bitfield name="COLOR_OFFSET" low="23" high="31" shr="12" type="hex"/>
	</reg32>
	<!-- 0x88e6-0x88ef invalid -->
	<!-- always 0x0 ? -->
	<reg32 offset="0x88f0" name="RB_UNKNOWN_88F0" low="0" high="11" usage="cmd"/>
	<!-- could be for separate stencil? (or may not be a flag buffer at all) -->
	<reg64 offset="0x88f1" name="RB_UNK_FLAG_BUFFER_BASE" type="waddress" align="64"/>
	<reg32 offset="0x88f3" name="RB_UNK_FLAG_BUFFER_PITCH" type="a6xx_flag_buffer_pitch"/>

	<reg32 offset="0x88f4" name="RB_VRS_CONFIG" usage="rp_blit">
		<bitfield name="UNK2" pos="2" type="boolean"/>
		<bitfield name="PIPELINE_FSR_ENABLE" pos="4" type="boolean"/>
		<bitfield name="ATTACHMENT_FSR_ENABLE" pos="5" type="boolean"/>
		<bitfield name="PRIMITIVE_FSR_ENABLE" pos="18" type="boolean"/>
	</reg32>
	<reg32 offset="0x88f5" name="RB_BIN_FOVEAT" variants="A7XX-" usage="cmd">
		<bitfield name="BINSCALEEN" pos="6" type="boolean"/>
	</reg32>
	<!-- 0x88f6-0x88ff invalid -->
	<reg64 offset="0x8900" name="RB_DEPTH_FLAG_BUFFER_BASE" type="waddress" align="64" usage="rp_blit"/>
	<reg32 offset="0x8902" name="RB_DEPTH_FLAG_BUFFER_PITCH" usage="rp_blit">
		<bitfield name="PITCH" low="0" high="6" shr="6" type="uint"/>
		<!-- TODO: actually part of array pitch -->
		<bitfield name="UNK8" low="8" high="10"/>
		<bitfield name="ARRAY_PITCH" low="11" high="27" shr="7" type="uint"/>
	</reg32>

	<array offset="0x8903" name="RB_COLOR_FLAG_BUFFER" stride="3" length="8" usage="rp_blit">
		<reg64 offset="0" name="ADDR" type="waddress" align="64"/>
		<reg32 offset="2" name="PITCH" type="a6xx_flag_buffer_pitch"/>
	</array>
	<!-- 0x891b-0x8926 invalid -->
	<doc>
		RB_SAMPLE_COUNTER_BASE register is used up to (and including) a730. After that
		the address is specified through CP_EVENT_WRITE7::WRITE_SAMPLE_COUNT.
	</doc>
	<reg64 offset="0x8927" name="RB_SAMPLE_COUNTER_BASE" type="waddress" align="16" usage="cmd"/>
	<!-- 0x8929-0x89ff invalid -->

	<!-- TODO: there are some registers in the 0x8a00-0x8bff range -->

	<!--
		These show up in a6xx gen3+ but so far haven't found an example of
		blob writing non-zero:
	 -->
	<reg32 offset="0x8a00" name="RB_UNKNOWN_8A00" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0x8a10" name="RB_UNKNOWN_8A10" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0x8a20" name="RB_UNKNOWN_8A20" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0x8a30" name="RB_UNKNOWN_8A30" variants="A6XX" usage="rp_blit"/>

	<reg32 offset="0x8c00" name="RB_A2D_BLT_CNTL" type="a6xx_a2d_bit_cntl" usage="rp_blit"/>
	<reg32 offset="0x8c01" name="RB_A2D_PIXEL_CNTL" low="0" high="31" usage="rp_blit"/>

	<bitset name="a6xx_a2d_src_texture_info" inline="yes">
		<bitfield name="COLOR_FORMAT" low="0" high="7" type="a6xx_format"/>
		<bitfield name="TILE_MODE" low="8" high="9" type="a6xx_tile_mode"/>
		<bitfield name="COLOR_SWAP" low="10" high="11" type="a3xx_color_swap"/>
		<bitfield name="FLAGS" pos="12" type="boolean"/>
		<bitfield name="SRGB" pos="13" type="boolean"/>
		<bitfield name="SAMPLES" low="14" high="15" type="a3xx_msaa_samples"/>
		<bitfield name="FILTER" pos="16" type="boolean"/>
		<bitfield name="UNK17" pos="17" type="boolean"/>
		<bitfield name="SAMPLES_AVERAGE" pos="18" type="boolean"/>
		<bitfield name="UNK19" pos="19" type="boolean"/>
		<bitfield name="UNK20" pos="20" type="boolean"/>
		<bitfield name="UNK21" pos="21" type="boolean"/>
		<bitfield name="UNK22" pos="22" type="boolean"/>
		<bitfield name="UNK23" low="23" high="26"/>
		<bitfield name="UNK28" pos="28" type="boolean"/>
		<bitfield name="MUTABLEEN" pos="29" type="boolean" variants="A7XX-"/>
	</bitset>

	<bitset name="a6xx_a2d_dest_buffer_info" inline="yes">
		<bitfield name="COLOR_FORMAT" low="0" high="7" type="a6xx_format"/>
		<bitfield name="TILE_MODE" low="8" high="9" type="a6xx_tile_mode"/>
		<bitfield name="COLOR_SWAP" low="10" high="11" type="a3xx_color_swap"/>
		<bitfield name="FLAGS" pos="12" type="boolean"/>
		<bitfield name="SRGB" pos="13" type="boolean"/>
		<bitfield name="SAMPLES" low="14" high="15" type="a3xx_msaa_samples"/>
		<bitfield name="MUTABLEEN" pos="17" type="boolean" variants="A7XX-"/>
	</bitset>

	<!-- 0x8c02-0x8c16 invalid -->
	<reg32 offset="0x8c17" name="RB_A2D_DEST_BUFFER_INFO" type="a6xx_a2d_dest_buffer_info" usage="rp_blit"/>
	<reg64 offset="0x8c18" name="RB_A2D_DEST_BUFFER_BASE" type="waddress" align="64" usage="rp_blit"/>
	<reg32 offset="0x8c1a" name="RB_A2D_DEST_BUFFER_PITCH" low="0" high="15" shr="6" type="uint" usage="rp_blit"/>
	<!-- this is a guess but seems likely (for NV12/IYUV): -->
	<reg64 offset="0x8c1b" name="RB_A2D_DEST_BUFFER_BASE_1" type="waddress" align="64" usage="rp_blit"/>
	<reg32 offset="0x8c1d" name="RB_A2D_DEST_BUFFER_PITCH_1" low="0" high="15" shr="6" type="uint" usage="rp_blit"/>
	<reg64 offset="0x8c1e" name="RB_A2D_DEST_BUFFER_BASE_2" type="waddress" align="64" usage="rp_blit"/>

	<reg64 offset="0x8c20" name="RB_A2D_DEST_FLAG_BUFFER_BASE" type="waddress" align="64" usage="rp_blit"/>
	<reg32 offset="0x8c22" name="RB_A2D_DEST_FLAG_BUFFER_PITCH" type="a6xx_flag_buffer_pitch" usage="rp_blit"/>
	<!-- this is a guess but seems likely (for NV12 with UBWC): -->
	<reg64 offset="0x8c23" name="RB_A2D_DEST_FLAG_BUFFER_BASE_1" type="waddress" align="64" usage="rp_blit"/>
	<reg32 offset="0x8c25" name="RB_A2D_DEST_FLAG_BUFFER_PITCH_1" low="0" high="7" shr="6" type="uint" usage="rp_blit"/>

	<!-- TODO: 0x8c26-0x8c33 are all full 32-bit registers -->
	<!-- unlike a5xx, these are per channel values rather than packed -->
	<reg32 offset="0x8c2c" name="RB_A2D_CLEAR_COLOR_DW0" usage="rp_blit"/>
	<reg32 offset="0x8c2d" name="RB_A2D_CLEAR_COLOR_DW1" usage="rp_blit"/>
	<reg32 offset="0x8c2e" name="RB_A2D_CLEAR_COLOR_DW2" usage="rp_blit"/>
	<reg32 offset="0x8c2f" name="RB_A2D_CLEAR_COLOR_DW3" usage="rp_blit"/>

	<reg32 offset="0x8c34" name="RB_UNKNOWN_8C34" variants="A7XX-" usage="cmd"/>

	<!-- 0x8c35-0x8dff invalid -->

	<!-- always 0x1 ? either doesn't exist for a650 or write-only: -->
	<reg32 offset="0x8e01" name="RB_UNKNOWN_8E01" usage="cmd"/>
	<!-- 0x8e00-0x8e03 invalid -->
	<reg32 offset="0x8e04" name="RB_DBG_ECO_CNTL" usage="cmd"/> <!-- TODO: valid mask 0xfffffeff -->
	<reg32 offset="0x8e05" name="RB_ADDR_MODE_CNTL" pos="0" type="a5xx_address_mode"/>
	<!-- 0x02080000 in GMEM, zero otherwise?  -->
	<reg32 offset="0x8e06" name="RB_CCU_DBG_ECO_CNTL" variants="A7XX-" usage="cmd"/>

	<reg32 offset="0x8e07" name="RB_CCU_CNTL" usage="cmd" variants="A6XX">
		<bitfield name="GMEM_FAST_CLEAR_DISABLE" pos="0" type="boolean"/>
		<!-- concurrent resolves are apparently a 2-bit enum on a650+ -->
		<bitfield name="CONCURRENT_RESOLVE" pos="2" type="boolean"/>
		<bitfield name="DEPTH_OFFSET_HI" pos="7" type="hex"/>
		<bitfield name="COLOR_OFFSET_HI" pos="9" type="hex"/>
		<bitfield name="DEPTH_CACHE_SIZE" low="10" high="11" type="a6xx_ccu_cache_size"/>
		<!-- GMEM offset of CCU depth cache -->
		<bitfield name="DEPTH_OFFSET" low="12" high="20" shr="12" type="hex"/>
		<bitfield name="COLOR_CACHE_SIZE" low="21" high="22" type="a6xx_ccu_cache_size"/>
		<!-- GMEM offset of CCU color cache
			for GMEM rendering, we set it to GMEM size minus the minimum
			CCU color cache size. CCU color cache will be needed in some
			resolve cases, and in those cases we need to reserve the end
			of GMEM for color cache.
		-->
		<bitfield name="COLOR_OFFSET" low="23" high="31" shr="12" type="hex"/>
		<!--TODO: valid mask 0xfffffc1f -->
	</reg32>
	<enum name="a7xx_concurrent_resolve_mode">
		<value value="0x0" name="CONCURRENT_RESOLVE_MODE_DISABLED"/>
		<value value="0x1" name="CONCURRENT_RESOLVE_MODE_1"/>
		<value value="0x2" name="CONCURRENT_RESOLVE_MODE_2"/>
	</enum>
	<enum name="a7xx_concurrent_unresolve_mode">
		<value value="0x0" name="CONCURRENT_UNRESOLVE_MODE_DISABLED"/>
		<value value="0x1" name="CONCURRENT_UNRESOLVE_MODE_PARTIAL"/>
		<value value="0x3" name="CONCURRENT_UNRESOLVE_MODE_FULL"/>
	</enum>
	<reg32 offset="0x8e07" name="RB_CCU_CNTL" usage="cmd" variants="A7XX-">
		<bitfield name="GMEM_FAST_CLEAR_DISABLE" pos="0" type="boolean"/>
		<bitfield name="CONCURRENT_RESOLVE_MODE" low="2" high="3" type="a7xx_concurrent_resolve_mode"/>
		<bitfield name="CONCURRENT_UNRESOLVE_MODE" low="5" high="6" type="a7xx_concurrent_unresolve_mode"/>
		<!-- rest of the bits were moved to RB_CCU_CACHE_CNTL -->
	</reg32>
	<reg32 offset="0x8e08" name="RB_NC_MODE_CNTL">
		<bitfield name="MODE" pos="0" type="boolean"/>
		<bitfield name="LOWER_BIT" low="1" high="2" type="uint"/>
		<bitfield name="MIN_ACCESS_LENGTH" pos="3" type="boolean"/> <!-- true=64b false=32b -->
		<bitfield name="AMSBC" pos="4" type="boolean"/>
		<bitfield name="UPPER_BIT" pos="10" type="uint"/>
		<bitfield name="RGB565_PREDICATOR" pos="11" type="boolean"/>
		<bitfield name="UNK12" low="12" high="13"/>
	</reg32>
	<reg32 offset="0x8e09" name="RB_UNKNOWN_8E09" variants="A7XX-" usage="cmd"/>
	<!-- 0x8e09-0x8e0f invalid -->
	<array offset="0x8e10" name="RB_PERFCTR_RB_SEL" stride="1" length="8"/>
	<array offset="0x8e18" name="RB_PERFCTR_CCU_SEL" stride="1" length="5"/>
	<!-- 0x8e1d-0x8e1f invalid -->
	<!-- 0x8e20-0x8e25 more perfcntr sel? -->
	<!-- 0x8e26-0x8e27 invalid -->
	<reg32 offset="0x8e28" name="RB_CMP_DBG_ECO_CNTL"/>
	<!-- 0x8e29-0x8e2b invalid -->
	<array offset="0x8e2c" name="RB_PERFCTR_CMP_SEL" stride="1" length="4"/>
	<array offset="0x8e30" name="RB_PERFCTR_UFC_SEL" stride="1" length="6" variants="A7XX-"/>
	<reg32 offset="0x8e3b" name="RB_RB_SUB_BLOCK_SEL_CNTL_HOST"/>
	<reg32 offset="0x8e3d" name="RB_RB_SUB_BLOCK_SEL_CNTL_CD"/>
	<!-- 0x8e3e-0x8e4f invalid -->
	<!-- GMEM save/restore for preemption: -->
	<reg32 offset="0x8e50" name="RB_CONTEXT_SWITCH_GMEM_SAVE_RESTORE_ENABLE" pos="0" type="boolean"/>
	<!-- address for GMEM save/restore? -->
	<reg32 offset="0x8e51" name="RB_CONTEXT_SWITCH_GMEM_SAVE_RESTORE_ADDR" type="waddress" align="1"/>
	<!-- 0x8e53-0x8e7f invalid -->
	<reg32 offset="0x8e79" name="RB_UNKNOWN_8E79" variants="A7XX-" usage="cmd"/>
	<!-- 0x8e80-0x8e83 are valid -->
	<!-- 0x8e84-0x90ff invalid -->

	<!-- 0x9000-0x90ff invalid -->

	<reg32 offset="0x9100" name="VPC_GS_PARAM" variants="A6XX" usage="rp_blit">
		<bitfield name="LINELENGTHLOC" low="0" high="7" type="uint"/>
	</reg32>

	<bitset name="a6xx_vpc_xs_clip_cntl" inline="yes">
		<bitfield name="CLIP_MASK" low="0" high="7" type="uint"/>
		<!-- there can be up to 8 total clip/cull distance outputs,
		     but apparenly VPC can only deal with vec4, so when there are
		     more than 4 outputs a second location needs to be programmed
		-->
		<bitfield name="CLIP_DIST_03_LOC" low="8" high="15" type="uint"/>
		<bitfield name="CLIP_DIST_47_LOC" low="16" high="23" type="uint"/>
	</bitset>
	<reg32 offset="0x9101" name="VPC_VS_CLIP_CULL_CNTL" type="a6xx_vpc_xs_clip_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9102" name="VPC_GS_CLIP_CULL_CNTL" type="a6xx_vpc_xs_clip_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9103" name="VPC_DS_CLIP_CULL_CNTL" type="a6xx_vpc_xs_clip_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<reg32 offset="0x9311" name="VPC_VS_CLIP_CULL_CNTL_V2" type="a6xx_vpc_xs_clip_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9312" name="VPC_GS_CLIP_CULL_CNTL_V2" type="a6xx_vpc_xs_clip_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9313" name="VPC_DS_CLIP_CULL_CNTL_V2" type="a6xx_vpc_xs_clip_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_vpc_xs_siv_cntl" inline="yes">
		<bitfield name="LAYERLOC" low="0" high="7" type="uint"/>
		<bitfield name="VIEWLOC" low="8" high="15" type="uint"/>
		<bitfield name="SHADINGRATELOC" low="16" high="23" type="uint" variants="A7XX-"/>
	</bitset>

	<reg32 offset="0x9104" name="VPC_VS_SIV_CNTL" type="a6xx_vpc_xs_siv_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9105" name="VPC_GS_SIV_CNTL" type="a6xx_vpc_xs_siv_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9106" name="VPC_DS_SIV_CNTL" type="a6xx_vpc_xs_siv_cntl" variants="A6XX-A7XX" usage="rp_blit"/>


	<reg32 offset="0x9314" name="VPC_VS_SIV_CNTL_V2" type="a6xx_vpc_xs_siv_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9315" name="VPC_GS_SIV_CNTL_V2" type="a6xx_vpc_xs_siv_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9316" name="VPC_DS_SIV_CNTL_V2" type="a6xx_vpc_xs_siv_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_vpc_rast_stream_cntl" inline="yes">
		<!-- which stream to send to GRAS -->
		<bitfield name="STREAM" low="0" high="1" type="uint"/>
		<!-- discard primitives before rasterization -->
		<bitfield name="DISCARD" pos="2" type="boolean"/>
	</bitset>

	<reg32 offset="0x9980" name="VPC_RAST_STREAM_CNTL" type="a6xx_vpc_rast_stream_cntl" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0x9107" name="VPC_RAST_STREAM_CNTL" type="a6xx_vpc_rast_stream_cntl" variants="A7XX" usage="rp_blit"/>
	<reg32 offset="0x9317" name="VPC_RAST_STREAM_CNTL_V2" type="a6xx_vpc_rast_stream_cntl" variants="A7XX" usage="rp_blit"/>

	<reg32 offset="0x9107" name="VPC_UNKNOWN_9107" variants="A6XX" usage="rp_blit">
		<!-- this mirrors VPC_RAST_STREAM_CNTL::DISCARD, although it seems it's unused -->
		<bitfield name="RASTER_DISCARD" pos="0" type="boolean"/>
		<bitfield name="UNK2" pos="2" type="boolean"/>
	</reg32>

	<reg32 offset="0x9108" name="VPC_RAST_CNTL" type="a6xx_rast_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<bitset name="a6xx_pc_cntl" inline="yes">
		<bitfield name="PRIMITIVE_RESTART" pos="0" type="boolean"/>
		<bitfield name="PROVOKING_VTX_LAST" pos="1" type="boolean"/>
		<bitfield name="D3D_VERTEX_ORDERING" pos="2" type="boolean">
			<doc>
				Swaps TESS_CW_TRIS/TESS_CCW_TRIS, and also makes
				triangle fans and triangle strips use the D3D
				order instead of the OpenGL order.
			</doc>
		</bitfield>
		<bitfield name="UNK3" pos="3" type="boolean"/>
	</bitset>

	<bitset name="a6xx_gs_param_0" inline="yes">
		<doc>
		  geometry shader
		</doc>
		<!-- TODO: first 16 bits are valid so something is wrong or missing here -->
		<bitfield name="GS_VERTICES_OUT" low="0" high="7" type="uint"/>
		<bitfield name="GS_INVOCATIONS" low="10" high="14" type="uint"/>
		<bitfield name="LINELENGTHEN" pos="15" type="boolean"/>
		<bitfield name="GS_OUTPUT" low="16" high="17" type="a6xx_tess_output"/>
		<bitfield name="UNK18" pos="18"/>
	</bitset>

	<bitset name="a6xx_stereo_rendering_cntl" inline="yes">
		<bitfield name="ENABLE" pos="0" type="boolean"/>
		<bitfield name="DISABLEMULTIPOS" pos="1" type="boolean">
			<doc>
				Multi-position output lets the last geometry
				stage shader write multiple copies of
				gl_Position. If disabled then the VS is run once
				for each view, and ViewID is passed as a
				register to the VS.
			</doc>
		</bitfield>
		<bitfield name="VIEWS" low="2" high="6" type="uint"/>
	</bitset>

	<reg32 offset="0x9109" name="VPC_PC_CNTL" type="a6xx_pc_cntl" variants="A7XX" usage="rp_blit"/>
	<reg32 offset="0x910a" name="VPC_GS_PARAM_0" type="a6xx_gs_param_0" variants="A7XX" usage="rp_blit"/>
	<reg32 offset="0x910b" name="VPC_STEREO_RENDERING_VIEWMASK" type="hex" low="0" high="15" variants="A7XX" usage="rp_blit"/>
	<reg32 offset="0x910c" name="VPC_STEREO_RENDERING_CNTL" type="a6xx_stereo_rendering_cntl" variants="A7XX" usage="rp_blit"/>

	<enum name="a6xx_varying_interp_mode">
		<value value="0" name="INTERP_SMOOTH"/>
		<value value="1" name="INTERP_FLAT"/>
		<value value="2" name="INTERP_ZERO"/>
		<value value="3" name="INTERP_ONE"/>
	</enum>

	<enum name="a6xx_varying_ps_repl_mode">
		<value value="0" name="PS_REPL_NONE"/>
		<value value="1" name="PS_REPL_S"/>
		<value value="2" name="PS_REPL_T"/>
		<value value="3" name="PS_REPL_ONE_MINUS_T"/>
	</enum>

	<!-- 0x9109-0x91ff invalid -->
	<array offset="0x9200" name="VPC_VARYING_INTERP_MODE" stride="1" length="8" variants="A6XX-A7XX" usage="rp_blit">
		<doc>Packed array of a6xx_varying_interp_mode</doc>
		<reg32 offset="0x0" name="MODE"/>
	</array>
	<array offset="0x9208" name="VPC_VARYING_REPLACE_MODE" stride="1" length="8" variants="A6XX-A7XX" usage="rp_blit">
		<doc>Packed array of a6xx_varying_ps_repl_mode</doc>
		<reg32 offset="0x0" name="MODE"/>
	</array>

	<!-- always 0x0 -->
	<reg32 offset="0x9210" name="VPC_UNKNOWN_9210" low="0" high="31" variants="A6XX" usage="cmd"/>
	<reg32 offset="0x9211" name="VPC_UNKNOWN_9211" low="0" high="31" variants="A6XX" usage="cmd"/>

	<array offset="0x9212" name="VPC_VARYING_LM_TRANSFER_CNTL" stride="1" length="4" variants="A6XX-A7XX" usage="rp_blit">
		<!-- one bit per varying component: -->
		<reg32 offset="0" name="DISABLE"/>
	</array>

	<bitset name="a6xx_vpc_so_mapping_wptr" inline="yes">
		<!--
			Choose which DWORD to write to. There is an array of
			(4 * 64) DWORD's, dumped in the devcoredump at
			HLSQ_INST_RAM dword 0x400. Each DWORD corresponds to a
			(VPC location, stream) pair like so:

			location 0, stream 0
			location 2, stream 0
			...
			location 126, stream 0
			location 0, stream 1
			location 2, stream 1
			...
			location 126, stream 1
			location 0, stream 2
			...

			When EmitStreamVertex(N) happens, the HW goes to DWORD
			64 * N and then "executes" the next 64 DWORD's.

			This field is auto-incremented when VPC_SO_MAPPING_PORT is
			written to.
		-->
		<bitfield name="ADDR" low="0" high="7" type="hex"/>
		<!-- clear all A_EN and B_EN bits for all DWORD's -->
		<bitfield name="RESET" pos="16" type="boolean"/>
	</bitset>

	<reg32 offset="0x9216" name="VPC_SO_MAPPING_WPTR" type="a6xx_vpc_so_mapping_wptr" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_vpc_so_mapping_port" inline="yes">
		<bitfield name="A_BUF" low="0" high="1" type="uint"/>
		<bitfield name="A_OFF" low="2" high="10" shr="2" type="uint"/>
		<bitfield name="A_EN" pos="11" type="boolean"/>
		<bitfield name="B_BUF" low="12" high="13" type="uint"/>
		<bitfield name="B_OFF" low="14" high="22" shr="2" type="uint"/>
		<bitfield name="B_EN" pos="23" type="boolean"/>
	</bitset>

	<!-- special register, write multiple times to load SO program (not readable) -->
	<reg32 offset="0x9217" name="VPC_SO_MAPPING_PORT" type="a6xx_vpc_so_mapping_port" variants="A6XX-A7XX" usage="rp_blit"/>

	<reg64 offset="0x9218" name="VPC_SO_QUERY_BASE" type="waddress" align="32" variants="A6XX-A7XX" usage="cmd"/>

	<array offset="0x921a" name="VPC_SO" stride="7" length="4" variants="A6XX-A7XX" usage="cmd">
		<reg64 offset="0" name="BUFFER_BASE" type="waddress" align="32"/>
		<reg32 offset="2" name="BUFFER_SIZE" low="2" high="31" shr="2"/>
		<reg32 offset="3" name="BUFFER_STRIDE" low="0" high="9" shr="2"/>
		<reg32 offset="4" name="BUFFER_OFFSET" low="2" high="31" shr="2"/>
		<reg64 offset="5" name="FLUSH_BASE" type="waddress" align="32"/>
	</array>

	<bitset name="a6xx_vpc_replace_mode_cntl" inline="yes">
		<bitfield name="INVERT" pos="0" type="boolean"/>
	</bitset>

	<reg32 offset="0x9236" name="VPC_REPLACE_MODE_CNTL" type="a6xx_vpc_replace_mode_cntl" variants="A6XX-A7XX" usage="cmd"/>

	<reg32 offset="0x9300" name="VPC_ROTATION_CNTL" low="0" high="2" variants="A6XX-A7XX" usage="cmd"/>

	<bitset name="a6xx_vpc_xs_cntl" inline="yes">
		<doc>
			num of varyings plus four for gl_Position (plus one if gl_PointSize)
			plus # of transform-feedback (streamout) varyings if using the
			hw streamout (rather than stg instructions in shader)
		</doc>
		<bitfield name="STRIDE_IN_VPC" low="0" high="7" type="uint"/>
		<bitfield name="POSITIONLOC" low="8" high="15" type="uint"/>
		<bitfield name="PSIZELOC" low="16" high="23" type="uint"/>
		<bitfield name="EXTRAPOS" low="24" high="27" type="uint">
			<doc>
				The number of extra copies of POSITION, i.e.
				number of views minus one when multi-position
				output is enabled, otherwise 0.
			</doc>
		</bitfield>
	</bitset>

	<reg32 offset="0x9301" name="VPC_VS_CNTL" type="a6xx_vpc_xs_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9302" name="VPC_GS_CNTL" type="a6xx_vpc_xs_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9303" name="VPC_DS_CNTL" type="a6xx_vpc_xs_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_vpc_ps_cntl" inline="yes">
		<bitfield name="NUMNONPOSVAR" low="0" high="7" type="uint"/>
		<!-- for fixed-function (i.e. no GS) gl_PrimitiveID in FS -->
		<bitfield name="PRIMIDLOC" low="8" high="15" type="uint"/>
		<bitfield name="VARYING" pos="16" type="boolean"/>
		<bitfield name="VIEWIDLOC" low="24" high="31" type="uint">
			<doc>
				This VPC location will be overwritten with
				ViewID when multiview is enabled. It's used when
				fragment shaders read ViewID. It's only
				strictly required for multi-position output,
				where the same VS invocation is used for all the
				views at once, but it can be used when multi-pos
				output is disabled too, to avoid having to pass
				ViewID through the VS.
			</doc>
		</bitfield>
	</bitset>

	<reg32 offset="0x9304" name="VPC_PS_CNTL" type="a6xx_vpc_ps_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_vpc_so_cntl" inline="yes">
		<!--
		It's offset by 1, and 0 means "disabled"
		-->
		<bitfield name="BUF0_STREAM" low="0" high="2" type="uint"/>
		<bitfield name="BUF1_STREAM" low="3" high="5" type="uint"/>
		<bitfield name="BUF2_STREAM" low="6" high="8" type="uint"/>
		<bitfield name="BUF3_STREAM" low="9" high="11" type="uint"/>
		<bitfield name="STREAM_ENABLE" low="15" high="18" type="hex"/>
	</bitset>

	<reg32 offset="0x9305" name="VPC_SO_CNTL" type="a6xx_vpc_so_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_so_override" inline="yes">
		<bitfield name="DISABLE" pos="0" type="boolean"/>
	</bitset>

	<reg32 offset="0x9306" name="VPC_SO_OVERRIDE" type="a6xx_so_override" variants="A6XX-A7XX" usage="rp_blit"/>

	<reg32 offset="0x9807" name="PC_DGEN_SO_OVERRIDE" type="a6xx_so_override" variants="A7XX" usage="rp_blit"/>

	<reg32 offset="0x9307" name="VPC_PS_RAST_CNTL" type="a6xx_rast_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<reg32 offset="0x9308" name="VPC_ATTR_BUF_GMEM_SIZE" variants="A7XX" type="uint" usage="rp_blit"/>
	<reg32 offset="0x9309" name="VPC_ATTR_BUF_GMEM_BASE" variants="A7XX" type="uint" usage="rp_blit"/>

	<reg32 offset="0x9b09" name="PC_ATTR_BUF_GMEM_SIZE" variants="A7XX" type="uint" usage="rp_blit"/>

	<reg32 offset="0x930a" name="VPC_UNKNOWN_930A" variants="A7XX"/>

	<reg32 offset="0x960a" name="VPC_FLATSHADE_MODE_CNTL" variants="A7XX"/>

	<!-- 0x9307-0x95ff invalid -->

	<!-- TODO: 0x9600-0x97ff range -->
	<reg32 offset="0x9600" name="VPC_DBG_ECO_CNTL" usage="cmd"/> <!-- always 0x0 ? TODO: 0x1fbf37ff valid mask -->
	<reg32 offset="0x9601" name="VPC_ADDR_MODE_CNTL" pos="0" type="a5xx_address_mode" usage="cmd"/>
	<reg32 offset="0x9602" name="VPC_UNKNOWN_9602" pos="0" usage="cmd"/> <!-- always 0x0 ? -->
	<reg32 offset="0x9603" name="VPC_UNKNOWN_9603" low="0" high="26"/>
	<array offset="0x9604" name="VPC_PERFCTR_VPC_SEL" stride="1" length="6" variants="A6XX"/>
	<array offset="0x960b" name="VPC_PERFCTR_VPC_SEL" stride="1" length="12" variants="A7XX-"/>
	<!-- 0x960a-0x9623 invalid -->
	<!-- TODO: regs from 0x9624-0x963a -->
	<!-- 0x963b-0x97ff invalid -->

	<reg32 offset="0x9800" name="PC_HS_PARAM_0" low="0" high="5" type="uint" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_pc_hs_param_1" inline="yes">
		<bitfield name="SIZE" low="0" high="10" type="uint"/>
		<bitfield name="UNK13" pos="13"/>
	</bitset>

	<reg32 offset="0x9801" name="PC_HS_PARAM_1" type="a6xx_pc_hs_param_1" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_pc_ds_param" inline="yes">
		<bitfield name="SPACING" low="0" high="1" type="a6xx_tess_spacing"/>
		<bitfield name="OUTPUT" low="2" high="3" type="a6xx_tess_output"/>
	</bitset>

	<reg32 offset="0x9802" name="PC_DS_PARAM" type="a6xx_pc_ds_param" variants="A6XX-A7XX" usage="rp_blit"/>

	<reg32 offset="0x9803" name="PC_RESTART_INDEX" low="0" high="31" type="uint" variants="A6XX-A7XX" usage="rp_blit"/>

	<reg32 offset="0x9804" name="PC_MODE_CNTL" low="0" high="7" variants="A6XX-A7XX" usage="rp_blit"/>

	<reg32 offset="0x9805" name="PC_POWER_CNTL" low="0" high="2" usage="rp_blit"/>

	<bitset name="a6xx_pc_ps_cntl" inline="yes">
		<bitfield name="PRIMITIVEIDEN" pos="0" type="boolean"/>
	</bitset>

	<reg32 offset="0x9806" name="PC_PS_CNTL" type="a6xx_pc_ps_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_pc_dgen_so_cntl" inline="yes">
		<bitfield name="STREAM_ENABLE" low="15" high="18" type="hex"/>
	</bitset>

	<!-- New in a6xx gen3+ -->
	<reg32 offset="0x9808" name="PC_DGEN_SO_CNTL" type="a6xx_pc_dgen_so_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_pc_dgen_su_conservative_ras_cntl" inline="yes">
		<bitfield name="CONSERVATIVERASEN" pos="0" type="boolean"/>
	</bitset>

	<reg32 offset="0x980a" name="PC_DGEN_SU_CONSERVATIVE_RAS_CNTL" type="a6xx_pc_dgen_su_conservative_ras_cntl" variants="A6XX-A7XX"/>

	<!-- 0x9840 - 0x9842 are not readable -->
	<bitset name="a6xx_draw_initiator" inline="yes">
		<bitfield name="STATE_ID" low="0" high="7"/>
	</bitset>

	<reg32 offset="0x9840" name="PC_DRAW_INITIATOR" type="a6xx_draw_initiator" variants="A6XX-A7XX"/>
	<reg32 offset="0x9841" name="PC_KERNEL_INITIATOR" type="a6xx_draw_initiator" variants="A6XX-A7XX"/>

	<bitset name="a6xx_event_initiator" inline="yes">
		<!-- I think only the low bit is actually used? -->
		<bitfield name="STATE_ID" low="16" high="23"/>
		<bitfield name="EVENT" low="0" high="6" type="vgt_event_type"/>
	</bitset>

	<reg32 offset="0x9842" name="PC_EVENT_INITIATOR" type="a6xx_event_initiator" variants="A6XX-A7XX"/>

	<!--
		0x9880 written in a lot of places by SQE, same value gets written
		to control reg 0x12a.  Set by CP_SET_MARKER, so lets name it after
		that
	 -->
	<reg32 offset="0x9880" name="PC_MARKER"/>

	<!-- 0x9843-0x997f invalid -->

	<reg32 offset="0x9981" name="PC_DGEN_RAST_CNTL" type="a6xx_rast_cntl" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0x9809" name="PC_DGEN_RAST_CNTL" type="a6xx_rast_cntl" variants="A7XX" usage="rp_blit"/>

	<!-- Both are a750+.
	     Probably needed to correctly overlap execution of several draws.
	-->
	<reg32 offset="0x9885" name="PC_HS_BUFFER_SIZE" variants="A7XX" usage="cmd"/>
	<!-- Blob adds a bit more space {0x10, 0x20, 0x30, 0x40} bytes, but the meaning of
	     this additional space is not known.
	-->
	<reg32 offset="0x9886" name="PC_TF_BUFFER_SIZE" variants="A7XX" usage="cmd"/>

	<!-- 0x9982-0x9aff invalid -->

	<reg32 offset="0x9b00" name="PC_CNTL" type="a6xx_pc_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<bitset name="a6xx_pc_xs_cntl" inline="yes">
		<doc>
			num of varyings plus four for gl_Position (plus one if gl_PointSize)
			plus # of transform-feedback (streamout) varyings if using the
			hw streamout (rather than stg instructions in shader)
		</doc>
		<bitfield name="STRIDE_IN_VPC" low="0" high="7" type="uint"/>
		<bitfield name="PSIZE" pos="8" type="boolean"/>
		<bitfield name="LAYER" pos="9" type="boolean"/>
		<bitfield name="VIEW" pos="10" type="boolean"/>
		<!-- note: PC_VS_CNTL doesn't have the PRIMITIVE_ID bit -->
		<!-- since HS can't output anything, only PRIMITIVE_ID is valid -->
		<bitfield name="PRIMITIVE_ID" pos="11" type="boolean"/>
		<bitfield name="CLIP_MASK" low="16" high="23" type="uint"/>
		<bitfield name="SHADINGRATE" pos="24" type="boolean" variants="A7XX-"/>
	</bitset>

	<reg32 offset="0x9b01" name="PC_VS_CNTL" type="a6xx_pc_xs_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9b02" name="PC_GS_CNTL" type="a6xx_pc_xs_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9b03" name="PC_HS_CNTL" type="a6xx_pc_xs_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0x9b04" name="PC_DS_CNTL" type="a6xx_pc_xs_cntl" variants="A6XX-A7XX" usage="rp_blit"/>

	<reg32 offset="0x9b05" name="PC_GS_PARAM_0" type="a6xx_gs_param_0" variants="A6XX-A7XX" usage="rp_blit"/>

	<reg32 offset="0x9b06" name="PC_PRIMITIVE_CNTL_6" variants="A6XX" usage="rp_blit">
		<doc>
		  size in vec4s of per-primitive storage for gs. TODO: not actually in VPC
		</doc>
		<bitfield name="STRIDE_IN_VPC" low="0" high="10" type="uint"/>
	</reg32>

	<reg32 offset="0x9b07" name="PC_STEREO_RENDERING_CNTL" type="a6xx_stereo_rendering_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<!-- mask of enabled views, doesn't exist on A630 -->
	<reg32 offset="0x9b08" name="PC_STEREO_RENDERING_VIEWMASK" type="hex" low="0" high="15" variants="A6XX-A7XX" usage="rp_blit"/>
	<!-- 0x9b09-0x9bff invalid -->
	<reg32 offset="0x9c00" name="PC_2D_EVENT_CMD">
		<!-- special register (but note first 8 bits can be written/read) -->
		<bitfield name="EVENT" low="0" high="6" type="vgt_event_type"/>
		<bitfield name="STATE_ID" low="8" high="15"/>
	</reg32>
	<!-- 0x9c01-0x9dff invalid -->
	<!-- TODO: 0x9e00-0xa000 range incomplete -->
	<reg32 offset="0x9e00" name="PC_DBG_ECO_CNTL"/>
	<reg32 offset="0x9e01" name="PC_ADDR_MODE_CNTL" type="a5xx_address_mode"/>
	<reg64 offset="0x9e04" name="PC_DMA_BASE" type="address" variants="A6XX-A7XX"/>
	<reg32 offset="0x9e06" name="PC_DMA_OFFSET" type="uint" variants="A6XX-A7XX"/>
	<reg32 offset="0x9e07" name="PC_DMA_SIZE" type="uint" variants="A6XX-A7XX"/>

	<reg64 offset="0x9e08" name="PC_TESS_BASE" variants="A6XX" type="waddress" align="32" usage="cmd"/>
	<reg64 offset="0x9810" name="PC_TESS_BASE" variants="A7XX" type="waddress" align="32" usage="cmd"/>

	<reg32 offset="0x9e0b" name="PC_DRAWCALL_CNTL" type="vgt_draw_initiator_a4xx" variants="A6XX-A7XX">
		<doc>
			Possibly not really "initiating" the draw but the layout is similar
			to VGT_DRAW_INITIATOR on older gens
		</doc>
	</reg32>
	<reg32 offset="0x9e0c" name="PC_DRAWCALL_INSTANCE_NUM" type="uint" variants="A6XX-A7XX"/>
	<reg32 offset="0x9e0d" name="PC_DRAWCALL_SIZE" type="uint" variants="A6XX-A7XX"/>

	<!-- These match the contents of CP_SET_BIN_DATA (not written directly) -->
	<bitset name="a6xx_pc_vis_stream_cntl" inline="yes">
		<bitfield name="UNK0" low="0" high="15"/>
		<bitfield name="VSC_SIZE" low="16" high="21" type="uint"/>
		<bitfield name="VSC_N" low="22" high="26" type="uint"/>
	</bitset>

	<reg32 offset="0x9e11" name="PC_VIS_STREAM_CNTL" type="a6xx_pc_vis_stream_cntl" variants="A6XX-A7XX"/>
	<reg64 offset="0x9e12" name="PC_PVIS_STREAM_BIN_BASE" type="waddress" align="32" variants="A6XX-A7XX"/>
	<reg64 offset="0x9e14" name="PC_DVIS_STREAM_BIN_BASE" type="waddress" align="32" variants="A6XX-A7XX"/>

	<bitset name="a6xx_pc_drawcall_cntl_override" inline="yes">
		<doc>Written by CP_SET_VISIBILITY_OVERRIDE handler</doc>
		<bitfield name="OVERRIDE" pos="0" type="boolean"/>
	</bitset>

	<reg32 offset="0x9e1c" name="PC_DRAWCALL_CNTL_OVERRIDE" type="a6xx_pc_drawcall_cntl_override" variants="A6XX-A7XX"/>

	<reg32 offset="0x9e24" name="PC_UNKNOWN_9E24" variants="A7XX-" usage="cmd"/>

	<array offset="0x9e34" name="PC_PERFCTR_PC_SEL" stride="1" length="8" variants="A6XX"/>
	<array offset="0x9e42" name="PC_PERFCTR_PC_SEL" stride="1" length="16" variants="A7XX-"/>

	<!-- always 0x0 -->
	<reg32 offset="0x9e72" name="PC_UNKNOWN_9E72" usage="cmd"/>

	<reg32 offset="0xa000" name="VFD_CNTL_0" usage="rp_blit">
		<bitfield name="FETCH_CNT" low="0" high="5" type="uint"/>
		<bitfield name="DECODE_CNT" low="8" high="13" type="uint"/>
	</reg32>
	<reg32 offset="0xa001" name="VFD_CNTL_1" usage="rp_blit">
		<bitfield name="REGID4VTX" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="REGID4INST" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="REGID4PRIMID" low="16" high="23" type="a3xx_regid"/>
		<!-- only used for VS in non-multi-position-output case -->
		<bitfield name="REGID4VIEWID" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0xa002" name="VFD_CNTL_2" usage="rp_blit">
		<bitfield name="REGID_HSRELPATCHID" low="0" high="7" type="a3xx_regid">
			<doc>
				This is the ID of the current patch within the
				subdraw, used to calculate the offset of the
				patch within the HS->DS buffers. When a draw is
				split into multiple subdraws then this differs
				from gl_PrimitiveID on the second, third, etc.
				subdraws.
			</doc>
		</bitfield>
		<bitfield name="REGID_INVOCATIONID" low="8" high="15" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0xa003" name="VFD_CNTL_3" usage="rp_blit">
		<bitfield name="REGID_DSPRIMID" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="REGID_DSRELPATCHID" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="REGID_TESSX" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="REGID_TESSY" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0xa004" name="VFD_CNTL_4" usage="rp_blit">
		<bitfield name="UNK0" low="0" high="7" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0xa005" name="VFD_CNTL_5" usage="rp_blit">
		<bitfield name="REGID_GSHEADER" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="UNK8" low="8" high="15" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0xa006" name="VFD_CNTL_6" usage="rp_blit">
		<!--
			True if gl_PrimitiveID is read via the FS
		-->
		<bitfield name="PRIMID4PSEN" pos="0" type="boolean"/>
	</reg32>

	<reg32 offset="0xa007" name="VFD_RENDER_MODE" usage="cmd">
		<bitfield name="RENDER_MODE" low="0" high="2" type="a6xx_render_mode"/>
	</reg32>

	<reg32 offset="0xa008" name="VFD_STEREO_RENDERING_CNTL" type="a6xx_stereo_rendering_cntl" usage="rp_blit"/>
	<reg32 offset="0xa009" name="VFD_MODE_CNTL" usage="cmd">
		<!-- add VFD_INDEX_OFFSET to REGID4VTX -->
		<bitfield name="VERTEX" pos="0" type="boolean"/>
		<!-- add VFD_INSTANCE_START_OFFSET to REGID4INST -->
		<bitfield name="INSTANCE" pos="1" type="boolean"/>
	</reg32>

	<reg32 offset="0xa00e" name="VFD_INDEX_OFFSET" usage="rp_blit"/>
	<reg32 offset="0xa00f" name="VFD_INSTANCE_START_OFFSET" usage="rp_blit"/>
	<array offset="0xa010" name="VFD_VERTEX_BUFFER" stride="4" length="32" usage="rp_blit">
		<reg64 offset="0x0" name="BASE" type="address" align="1"/>
		<reg32 offset="0x2" name="SIZE" type="uint"/>
		<reg32 offset="0x3" name="STRIDE" low="0" high="11" type="uint"/>
	</array>
	<array offset="0xa090" name="VFD_FETCH_INSTR" stride="2" length="32" usage="rp_blit">
		<reg32 offset="0x0" name="INSTR">
			<!-- IDX and byte OFFSET into VFD_VERTEX_BUFFER -->
			<bitfield name="IDX" low="0" high="4" type="uint"/>
			<bitfield name="OFFSET" low="5" high="16"/>
			<bitfield name="INSTANCED" pos="17" type="boolean"/>
			<bitfield name="FORMAT" low="20" high="27" type="a6xx_format"/>
			<bitfield name="SWAP" low="28" high="29" type="a3xx_color_swap"/>
			<bitfield name="UNK30" pos="30" type="boolean"/>
			<bitfield name="FLOAT" pos="31" type="boolean"/>
		</reg32>
		<reg32 offset="0x1" name="STEP_RATE" type="uint"/>
	</array>
	<array offset="0xa0d0" name="VFD_DEST_CNTL" stride="1" length="32" usage="rp_blit">
		<reg32 offset="0x0" name="INSTR">
			<bitfield name="WRITEMASK" low="0" high="3" type="hex"/>
			<bitfield name="REGID" low="4" high="11" type="a3xx_regid"/>
		</reg32>
	</array>

	<reg32 offset="0xa0f8" name="VFD_POWER_CNTL" low="0" high="2" usage="rp_blit"/>

	<reg32 offset="0xa600" name="VFD_DBG_ECO_CNTL" variants="A7XX-" usage="cmd"/>

	<reg32 offset="0xa601" name="VFD_ADDR_MODE_CNTL" type="a5xx_address_mode"/>
	<array offset="0xa610" name="VFD_PERFCTR_VFD_SEL" stride="1" length="8" variants="A6XX"/>
	<array offset="0xa610" name="VFD_PERFCTR_VFD_SEL" stride="1" length="16" variants="A7XX-"/>

	<!--
	Note: this seems to always be paired with another bit in another
	block.
	-->
	<enum name="a6xx_threadsize">
		<value value="0" name="THREAD64"/>
		<value value="1" name="THREAD128"/>
	</enum>

	<bitset name="a6xx_sp_xs_cntl_0" inline="yes">
		<!-- if set to SINGLE, only use 1 concurrent wave on each SP -->
		<bitfield name="THREADMODE" pos="0" type="a3xx_threadmode"/>
		<!--
		When b31 set we just see FULLREGFOOTPRINT set.  The pattern of
		used registers is a bit odd too:
			- used (half): 0-15 68-179 (cnt=128, max=179)
			- used (full): 0-33 50-69 71 73 75 77 79 81 83 85 87 89-105 107 109 111 113 115 117 119 121 123 125 127>
		whereas we usually see a (mostly) contiguous range of regs used.  But if
		I merge the full and half ranges (ie. rN counts as hr(N*2) and hr(N*2+1)),
		then:
			- used (merged): 0-191 (cnt=192, max=191)
		So I think if b31 is set, then the half precision registers overlap
		the full precision registers.  (Which seems like a pretty sensible
		feature, actually I'm not sure when you *wouldn't* want to use that,
		since it gives register allocation more flexibility)
		 -->
		<bitfield name="HALFREGFOOTPRINT" low="1" high="6" type="uint"/>
		<bitfield name="FULLREGFOOTPRINT" low="7" high="12" type="uint"/>
		<!-- could it be a low bit of branchstack? -->
		<bitfield name="UNK13" pos="13" type="boolean"/>
		<!-- seems to be nesting level for flow control:.. -->
		<bitfield name="BRANCHSTACK" low="14" high="19" type="uint"/>
	</bitset>

	<bitset name="a6xx_sp_xs_config" inline="yes">
		<!--
		Each of these are set if the given resource type is used
		with the Vulkan/bindless binding model.
		-->
		<bitfield name="BINDLESS_TEX" pos="0" type="boolean"/>
		<bitfield name="BINDLESS_SAMP" pos="1" type="boolean"/>
		<bitfield name="BINDLESS_UAV" pos="2" type="boolean"/>
		<bitfield name="BINDLESS_UBO" pos="3" type="boolean"/>

		<bitfield name="ENABLED" pos="8" type="boolean"/>
		<!--
		number of textures and samplers.. these might be swapped, with GL I
		always see the same value for both.
		 -->
		<bitfield name="NTEX" low="9" high="16" type="uint"/>
		<bitfield name="NSAMP" low="17" high="21" type="uint"/>
		<bitfield name="NUAV" low="22" high="28" type="uint"/>
	</bitset>

	<bitset name="a6xx_sp_xs_output_cntl" inline="yes">
		<!-- # of VS outputs including pos/psize -->
		<bitfield name="OUT" low="0" high="5" type="uint"/>
		<!-- FLAGS_REGID only for GS -->
		<bitfield name="FLAGS_REGID" low="6" high="13" type="a3xx_regid"/>
	</bitset>

	<reg32 offset="0xa800" name="SP_VS_CNTL_0" type="a6xx_sp_xs_cntl_0" usage="rp_blit">
		<!--
		This field actually controls all geometry stages. TCS, TES, and
		GS must have the same mergedregs setting as VS.
		-->
		<bitfield name="MERGEDREGS" pos="20" type="boolean"/>
		<!--
		Creates a separate preamble-only thread?

		Early preamble has the following limitations:
		- Only shared, a1, and consts regs could be used
		  (accessing other regs would result in GPU fault);
		- No cat5/cat6, only stc/ldc variants are working;
		- Values writen to shared regs are not accessible by the rest
		  of the shader;
		- Instructions before shps are also considered to be a part of
		  early preamble;

		Note, for all shaders from d3d11 games blob produced preambles
		compatible with early preamble mode.
		-->
		<bitfield name="EARLYPREAMBLE" pos="21" type="boolean"/>
	</reg32>
	<!-- bitmask of true/false conditions for VS brac.N instructions,
	     bit N corresponds to brac.N -->
	<reg32 offset="0xa801" name="SP_VS_BOOLEAN_CF_MASK" type="hex"/>
	<!-- # of VS outputs including pos/psize -->
	<reg32 offset="0xa802" name="SP_VS_OUTPUT_CNTL" type="a6xx_sp_xs_output_cntl" usage="rp_blit"/>
	<array offset="0xa803" name="SP_VS_OUTPUT" stride="1" length="16" usage="rp_blit">
		<reg32 offset="0x0" name="REG">
			<bitfield name="A_REGID" low="0" high="7" type="a3xx_regid"/>
			<bitfield name="A_COMPMASK" low="8" high="11" type="hex"/>
			<bitfield name="B_REGID" low="16" high="23" type="a3xx_regid"/>
			<bitfield name="B_COMPMASK" low="24" high="27" type="hex"/>
		</reg32>
	</array>
	<!--
	Starting with a5xx, position/psize outputs from shader end up in the
	SP_VS_OUTPUT map, with highest OUTLOCn position.  (Generally they are
	the last entries too, except when gl_PointCoord is used, blob inserts
	an extra varying after, but with a lower OUTLOC position.  If present,
	psize is last, preceded by position.
	 -->
	<array offset="0xa813" name="SP_VS_VPC_DEST" stride="1" length="8" usage="rp_blit">
		<reg32 offset="0x0" name="REG">
			<bitfield name="OUTLOC0" low="0" high="7" type="uint"/>
			<bitfield name="OUTLOC1" low="8" high="15" type="uint"/>
			<bitfield name="OUTLOC2" low="16" high="23" type="uint"/>
			<bitfield name="OUTLOC3" low="24" high="31" type="uint"/>
		</reg32>
	</array>

	<bitset name="a6xx_sp_xs_pvt_mem_param" inline="yes">
		<bitfield name="MEMSIZEPERITEM" low="0" high="7" shr="9">
			<doc>The size of memory that ldp/stp can address.</doc>
		</bitfield>
		<bitfield name="HWSTACKSIZEPERTHREAD" low="24" high="31">
                        <doc>
				Seems to be the same as a3xx. The maximum stack
				size in units of 4 calls, so a call depth of 7
				would result in a value of 2.
				TODO: What's the actual size per call, i.e. the
				size of the PC? a3xx docs say it's 16 bits
				there, but the length register now takes 28 bits
				so it's probably been bumped to 32 bits.
                        </doc>
		</bitfield>
	</bitset>

	<bitset name="a6xx_sp_xs_pvt_mem_size" inline="yes">
		<bitfield name="TOTALPVTMEMSIZE" low="0" high="17" shr="12"/>
		<bitfield name="PERWAVEMEMLAYOUT" pos="31" type="boolean">
			<doc>
				There are four indices used to compute the
				private memory location for an access:

				- stp/ldp offset
				- fiber id
				- wavefront id (a swizzled version of what "getwid" returns)
				- SP ID (the same as what "getspid" returns)

				The stride for the SP ID is always set by
				TOTALPVTMEMSIZE. In the per-wave layout, the
				indices are used in this order:

				- offset % 4 (offset within dword)
				- fiber id
				- offset / 4
				- wavefront id
				- SP ID

				and the stride for the wavefront ID is
				MEMSIZEPERITEM, multiplied by 128 (fibers per
				wavefront). In the per-fiber layout, the indices
				are used in this order:

				- offset
				- fiber id % 4
				- wavefront id
				- fiber id / 4
				- SP ID

				and the stride for the fiber id/wavefront id
				combo is MEMSIZEPERITEM.

				Note: Accesses of more than 1 dword do not work
				with per-fiber layout. The blob will fall back
				to per-wave instead.
			</doc>
		</bitfield>
	</bitset>

	<bitset name="a6xx_sp_xs_pvt_mem_stack_offset" inline="yes">
		<doc>
			This seems to be be the equivalent of HWSTACKOFFSET in
			a3xx. The ldp/stp offset formula above isn't affected by
			HWSTACKSIZEPERTHREAD at all, so the HW return address
			stack seems to be after all the normal per-SP private
			memory.
		</doc>
		<bitfield name="OFFSET" low="0" high="18" shr="11"/>
	</bitset>

	<reg32 offset="0xa81b" name="SP_VS_PROGRAM_COUNTER_OFFSET" type="uint" usage="rp_blit"/>
	<reg64 offset="0xa81c" name="SP_VS_BASE" type="address" align="32" usage="rp_blit"/>
	<reg32 offset="0xa81e" name="SP_VS_PVT_MEM_PARAM" type="a6xx_sp_xs_pvt_mem_param" usage="rp_blit"/>
	<reg64 offset="0xa81f" name="SP_VS_PVT_MEM_BASE" type="waddress" align="32" usage="rp_blit"/>
	<reg32 offset="0xa821" name="SP_VS_PVT_MEM_SIZE" type="a6xx_sp_xs_pvt_mem_size" usage="rp_blit"/>
	<reg32 offset="0xa822" name="SP_VS_TSIZE" low="0" high="7" type="uint" usage="rp_blit"/>
	<reg32 offset="0xa823" name="SP_VS_CONFIG" type="a6xx_sp_xs_config" usage="rp_blit"/>
	<reg32 offset="0xa824" name="SP_VS_INSTR_SIZE" low="0" high="27" type="uint" usage="rp_blit"/>
	<reg32 offset="0xa825" name="SP_VS_PVT_MEM_STACK_OFFSET" type="a6xx_sp_xs_pvt_mem_stack_offset" usage="rp_blit"/>
	<reg32 offset="0xa82d" name="SP_VS_VGS_CNTL" variants="A7XX-" usage="cmd"/>

	<reg32 offset="0xa830" name="SP_HS_CNTL_0" type="a6xx_sp_xs_cntl_0" usage="rp_blit">
		<!-- There is no mergedregs bit, that comes from the VS. -->
		<bitfield name="EARLYPREAMBLE" pos="20" type="boolean"/>
	</reg32>
	<!--
	Total size of local storage in dwords divided by the wave size.
	The maximum value is 64. With the wave size being always 64 for HS,
	the maximum size of local storage should be:
	 64 (wavesize) * 64 (SP_HS_CNTL_1) * 4 = 16k
	-->
	<reg32 offset="0xa831" name="SP_HS_CNTL_1" low="0" high="7" type="uint" usage="rp_blit"/>
	<reg32 offset="0xa832" name="SP_HS_BOOLEAN_CF_MASK" type="hex" usage="rp_blit"/>

	<!-- TODO: exact same layout as 0xa81b-0xa825 -->
	<reg32 offset="0xa833" name="SP_HS_PROGRAM_COUNTER_OFFSET" type="uint" usage="rp_blit"/>
	<reg64 offset="0xa834" name="SP_HS_BASE" type="address" align="32" usage="rp_blit"/>
	<reg32 offset="0xa836" name="SP_HS_PVT_MEM_PARAM" type="a6xx_sp_xs_pvt_mem_param" usage="rp_blit"/>
	<reg64 offset="0xa837" name="SP_HS_PVT_MEM_BASE" type="waddress" align="32" usage="rp_blit"/>
	<reg32 offset="0xa839" name="SP_HS_PVT_MEM_SIZE" type="a6xx_sp_xs_pvt_mem_size" usage="rp_blit"/>
	<reg32 offset="0xa83a" name="SP_HS_TSIZE" low="0" high="7" type="uint" usage="rp_blit"/>
	<reg32 offset="0xa83b" name="SP_HS_CONFIG" type="a6xx_sp_xs_config" usage="rp_blit"/>
	<reg32 offset="0xa83c" name="SP_HS_INSTR_SIZE" low="0" high="27" type="uint" usage="rp_blit"/>
	<reg32 offset="0xa83d" name="SP_HS_PVT_MEM_STACK_OFFSET" type="a6xx_sp_xs_pvt_mem_stack_offset" usage="rp_blit"/>
	<reg32 offset="0xa82f" name="SP_HS_VGS_CNTL" variants="A7XX-" usage="cmd"/>

	<reg32 offset="0xa840" name="SP_DS_CNTL_0" type="a6xx_sp_xs_cntl_0" usage="rp_blit">
		<!-- There is no mergedregs bit, that comes from the VS. -->
		<bitfield name="EARLYPREAMBLE" pos="20" type="boolean"/>
	</reg32>
	<reg32 offset="0xa841" name="SP_DS_BOOLEAN_CF_MASK" type="hex"/>

	<!-- TODO: exact same layout as 0xa802-0xa81a -->
	<reg32 offset="0xa842" name="SP_DS_OUTPUT_CNTL" type="a6xx_sp_xs_output_cntl" usage="rp_blit"/>
	<array offset="0xa843" name="SP_DS_OUTPUT" stride="1" length="16" usage="rp_blit">
		<reg32 offset="0x0" name="REG">
			<bitfield name="A_REGID" low="0" high="7" type="a3xx_regid"/>
			<bitfield name="A_COMPMASK" low="8" high="11" type="hex"/>
			<bitfield name="B_REGID" low="16" high="23" type="a3xx_regid"/>
			<bitfield name="B_COMPMASK" low="24" high="27" type="hex"/>
		</reg32>
	</array>
	<array offset="0xa853" name="SP_DS_VPC_DEST" stride="1" length="8" usage="rp_blit">
		<reg32 offset="0x0" name="REG">
			<bitfield name="OUTLOC0" low="0" high="7" type="uint"/>
			<bitfield name="OUTLOC1" low="8" high="15" type="uint"/>
			<bitfield name="OUTLOC2" low="16" high="23" type="uint"/>
			<bitfield name="OUTLOC3" low="24" high="31" type="uint"/>
		</reg32>
	</array>

	<!-- TODO: exact same layout as 0xa81b-0xa825 -->
	<reg32 offset="0xa85b" name="SP_DS_PROGRAM_COUNTER_OFFSET" type="uint" usage="rp_blit"/>
	<reg64 offset="0xa85c" name="SP_DS_BASE" type="address" align="32" usage="rp_blit"/>
	<reg32 offset="0xa85e" name="SP_DS_PVT_MEM_PARAM" type="a6xx_sp_xs_pvt_mem_param" usage="rp_blit"/>
	<reg64 offset="0xa85f" name="SP_DS_PVT_MEM_BASE" type="waddress" align="32" usage="rp_blit"/>
	<reg32 offset="0xa861" name="SP_DS_PVT_MEM_SIZE" type="a6xx_sp_xs_pvt_mem_size" usage="rp_blit"/>
	<reg32 offset="0xa862" name="SP_DS_TSIZE" low="0" high="7" type="uint" usage="rp_blit"/>
	<reg32 offset="0xa863" name="SP_DS_CONFIG" type="a6xx_sp_xs_config" usage="rp_blit"/>
	<reg32 offset="0xa864" name="SP_DS_INSTR_SIZE" low="0" high="27" type="uint" usage="rp_blit"/>
	<reg32 offset="0xa865" name="SP_DS_PVT_MEM_STACK_OFFSET" type="a6xx_sp_xs_pvt_mem_stack_offset" usage="rp_blit"/>
	<reg32 offset="0xa868" name="SP_DS_VGS_CNTL" variants="A7XX-" usage="cmd"/>

	<reg32 offset="0xa870" name="SP_GS_CNTL_0" type="a6xx_sp_xs_cntl_0" usage="rp_blit">
		<!-- There is no mergedregs bit, that comes from the VS. -->
		<bitfield name="EARLYPREAMBLE" pos="20" type="boolean"/>
	</reg32>
	<reg32 offset="0xa871" name="SP_GS_CNTL_1" low="0" high="7" type="uint" usage="rp_blit">
		<doc>
			Normally the size of the output of the last stage in
			dwords. It should be programmed as follows:

			size less than 63    - size
			size of 63 (?) or 64 - 63
			size greater than 64 - 64

			What to program when the size is 61-63 is a guess, but
			both the blob and ir3 align the size to 4 dword's so it
			doesn't matter in practice.
		</doc>
	</reg32>
	<reg32 offset="0xa872" name="SP_GS_BOOLEAN_CF_MASK" type="hex" usage="rp_blit"/>

	<!-- TODO: exact same layout as 0xa802-0xa81a -->
	<reg32 offset="0xa873" name="SP_GS_OUTPUT_CNTL" type="a6xx_sp_xs_output_cntl" usage="rp_blit"/>
	<array offset="0xa874" name="SP_GS_OUTPUT" stride="1" length="16" usage="rp_blit">
		<reg32 offset="0x0" name="REG">
			<bitfield name="A_REGID" low="0" high="7" type="a3xx_regid"/>
			<bitfield name="A_COMPMASK" low="8" high="11" type="hex"/>
			<bitfield name="B_REGID" low="16" high="23" type="a3xx_regid"/>
			<bitfield name="B_COMPMASK" low="24" high="27" type="hex"/>
		</reg32>
	</array>

	<array offset="0xa884" name="SP_GS_VPC_DEST" stride="1" length="8" usage="rp_blit">
		<reg32 offset="0x0" name="REG">
			<bitfield name="OUTLOC0" low="0" high="7" type="uint"/>
			<bitfield name="OUTLOC1" low="8" high="15" type="uint"/>
			<bitfield name="OUTLOC2" low="16" high="23" type="uint"/>
			<bitfield name="OUTLOC3" low="24" high="31" type="uint"/>
		</reg32>
	</array>

	<!-- TODO: exact same layout as 0xa81b-0xa825 -->
	<reg32 offset="0xa88c" name="SP_GS_PROGRAM_COUNTER_OFFSET" type="uint" usage="rp_blit"/>
	<reg64 offset="0xa88d" name="SP_GS_BASE" type="address" align="32" usage="rp_blit"/>
	<reg32 offset="0xa88f" name="SP_GS_PVT_MEM_PARAM" type="a6xx_sp_xs_pvt_mem_param" usage="rp_blit"/>
	<reg64 offset="0xa890" name="SP_GS_PVT_MEM_BASE" type="waddress" align="32" usage="rp_blit"/>
	<reg32 offset="0xa892" name="SP_GS_PVT_MEM_SIZE" type="a6xx_sp_xs_pvt_mem_size" usage="rp_blit"/>
	<reg32 offset="0xa893" name="SP_GS_TSIZE" low="0" high="7" type="uint" usage="rp_blit"/>
	<reg32 offset="0xa894" name="SP_GS_CONFIG" type="a6xx_sp_xs_config" usage="rp_blit"/>
	<reg32 offset="0xa895" name="SP_GS_INSTR_SIZE" low="0" high="27" type="uint" usage="rp_blit"/>
	<reg32 offset="0xa896" name="SP_GS_PVT_MEM_STACK_OFFSET" type="a6xx_sp_xs_pvt_mem_stack_offset" usage="rp_blit"/>
	<reg32 offset="0xa899" name="SP_GS_VGS_CNTL" variants="A7XX-" usage="cmd"/>

	<reg64 offset="0xa8a0" name="SP_VS_SAMPLER_BASE" type="address" align="16" usage="cmd"/>
	<reg64 offset="0xa8a2" name="SP_HS_SAMPLER_BASE" type="address" align="16" usage="cmd"/>
	<reg64 offset="0xa8a4" name="SP_DS_SAMPLER_BASE" type="address" align="16" usage="cmd"/>
	<reg64 offset="0xa8a6" name="SP_GS_SAMPLER_BASE" type="address" align="16" usage="cmd"/>
	<reg64 offset="0xa8a8" name="SP_VS_TEXMEMOBJ_BASE" type="address" align="64" usage="cmd"/>
	<reg64 offset="0xa8aa" name="SP_HS_TEXMEMOBJ_BASE" type="address" align="64" usage="cmd"/>
	<reg64 offset="0xa8ac" name="SP_DS_TEXMEMOBJ_BASE" type="address" align="64" usage="cmd"/>
	<reg64 offset="0xa8ae" name="SP_GS_TEXMEMOBJ_BASE" type="address" align="64" usage="cmd"/>

	<!-- TODO: 4 unknown bool registers 0xa8c0-0xa8c3 -->

	<reg32 offset="0xa980" name="SP_PS_CNTL_0" type="a6xx_sp_xs_cntl_0" usage="rp_blit">
		<bitfield name="THREADSIZE" pos="20" type="a6xx_threadsize"/>
		<bitfield name="UNK21" pos="21" type="boolean"/>
		<bitfield name="VARYING" pos="22" type="boolean"/>
		<bitfield name="LODPIXMASK" pos="23" type="boolean">
			<doc>
				Enable ALL helper invocations in a quad. Necessary for
				fine derivatives and quad subgroup ops.
			</doc>
		</bitfield>
		<bitfield name="INOUTREGOVERLAP" pos="24" type="boolean"/>
		<bitfield name="UNK25" pos="25" type="boolean"/>
		<bitfield name="PIXLODENABLE" pos="26" type="boolean">
			<doc>
				Enable helper invocations. Enables 3 out of 4 fragments,
				because the coarse derivatives only use half of the quad
				and so one pixel's value is always unused.
			</doc>
		</bitfield>
		<bitfield name="UNK27" pos="27" type="boolean"/>
		<bitfield name="EARLYPREAMBLE" pos="28" type="boolean"/>
		<bitfield name="MERGEDREGS" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="0xa981" name="SP_PS_BOOLEAN_CF_MASK" type="hex"/>
	<reg32 offset="0xa982" name="SP_PS_PROGRAM_COUNTER_OFFSET" type="uint" usage="rp_blit"/>
	<reg64 offset="0xa983" name="SP_PS_BASE" type="address" align="32" usage="rp_blit"/>
	<reg32 offset="0xa985" name="SP_PS_PVT_MEM_PARAM" type="a6xx_sp_xs_pvt_mem_param" usage="rp_blit"/>
	<reg64 offset="0xa986" name="SP_PS_PVT_MEM_BASE" type="waddress" align="32" usage="rp_blit"/>
	<reg32 offset="0xa988" name="SP_PS_PVT_MEM_SIZE" type="a6xx_sp_xs_pvt_mem_size" usage="rp_blit"/>

	<reg32 offset="0xa989" name="SP_BLEND_CNTL" usage="rp_blit">
		<!-- per-mrt enable bit -->
		<bitfield name="ENABLE_BLEND" low="0" high="7"/>
		<bitfield name="UNK8" pos="8" type="boolean"/>
		<bitfield name="DUAL_COLOR_IN_ENABLE" pos="9" type="boolean"/>
		<bitfield name="ALPHA_TO_COVERAGE" pos="10" type="boolean"/>
	</reg32>
	<reg32 offset="0xa98a" name="SP_SRGB_CNTL" usage="rp_blit">
		<!-- Same as RB_SRGB_CNTL -->
		<bitfield name="SRGB_MRT0" pos="0" type="boolean"/>
		<bitfield name="SRGB_MRT1" pos="1" type="boolean"/>
		<bitfield name="SRGB_MRT2" pos="2" type="boolean"/>
		<bitfield name="SRGB_MRT3" pos="3" type="boolean"/>
		<bitfield name="SRGB_MRT4" pos="4" type="boolean"/>
		<bitfield name="SRGB_MRT5" pos="5" type="boolean"/>
		<bitfield name="SRGB_MRT6" pos="6" type="boolean"/>
		<bitfield name="SRGB_MRT7" pos="7" type="boolean"/>
	</reg32>
	<reg32 offset="0xa98b" name="SP_PS_OUTPUT_MASK" usage="rp_blit">
		<bitfield name="RT0" low="0" high="3"/>
		<bitfield name="RT1" low="4" high="7"/>
		<bitfield name="RT2" low="8" high="11"/>
		<bitfield name="RT3" low="12" high="15"/>
		<bitfield name="RT4" low="16" high="19"/>
		<bitfield name="RT5" low="20" high="23"/>
		<bitfield name="RT6" low="24" high="27"/>
		<bitfield name="RT7" low="28" high="31"/>
	</reg32>
	<reg32 offset="0xa98c" name="SP_PS_OUTPUT_CNTL" usage="rp_blit">
		<bitfield name="DUAL_COLOR_IN_ENABLE" pos="0" type="boolean"/>
		<bitfield name="DEPTH_REGID" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="SAMPMASK_REGID" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="STENCILREF_REGID" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0xa98d" name="SP_PS_MRT_CNTL" usage="rp_blit">
		<bitfield name="MRT" low="0" high="3" type="uint"/>
	</reg32>

	<array offset="0xa98e" name="SP_PS_OUTPUT" stride="1" length="8" usage="rp_blit">
		<doc>per MRT</doc>
		<reg32 offset="0x0" name="REG">
			<bitfield name="REGID" low="0" high="7" type="a3xx_regid"/>
			<bitfield name="HALF_PRECISION" pos="8" type="boolean"/>
		</reg32>
	</array>

	<array offset="0xa996" name="SP_PS_MRT" stride="1" length="8" usage="rp_blit">
		<reg32 offset="0" name="REG">
			<bitfield name="COLOR_FORMAT" low="0" high="7" type="a6xx_format"/>
			<bitfield name="COLOR_SINT" pos="8" type="boolean"/>
			<bitfield name="COLOR_UINT" pos="9" type="boolean"/>
			<bitfield name="UNK10" pos="10" type="boolean"/>
		</reg32>
	</array>

	<reg32 offset="0xa99e" name="SP_PS_INITIAL_TEX_LOAD_CNTL" usage="rp_blit">
		<bitfield name="COUNT" low="0" high="2" type="uint"/>
		<bitfield name="IJ_WRITE_DISABLE" pos="3" type="boolean"/>
		<doc>
			Similar to "(eq)" flag but disables helper invocations
			after the texture prefetch.
		</doc>
		<bitfield name="ENDOFQUAD" pos="4" type="boolean" />
		<doc>
			Bypass writing to regs and overwrite output with color from
			CONSTSLOTID const regs.
		</doc>
		<bitfield name="WRITE_COLOR_TO_OUTPUT" pos="5" type="boolean"/>
		<bitfield name="CONSTSLOTID" low="6" high="14" type="uint"/>
		<!-- Blob never uses it -->
		<bitfield name="CONSTSLOTID4COORD" low="16" high="24" type="uint" variants="A7XX-"/>
	</reg32>
	<array offset="0xa99f" name="SP_PS_INITIAL_TEX_LOAD" stride="1" length="4" variants="A6XX" usage="rp_blit">
		<reg32 offset="0" name="CMD" variants="A6XX">
			<bitfield name="SRC" low="0" high="6" type="uint"/>
			<bitfield name="SAMP_ID" low="7" high="10" type="uint"/>
			<bitfield name="TEX_ID" low="11" high="15" type="uint"/>
			<bitfield name="DST" low="16" high="21" type="a3xx_regid"/>
			<bitfield name="WRMASK" low="22" high="25" type="hex"/>
			<bitfield name="HALF" pos="26" type="boolean"/>
			<doc>Results in color being zero</doc>
			<bitfield name="UNK27" pos="27" type="boolean"/>
			<bitfield name="BINDLESS" pos="28" type="boolean"/>
			<bitfield name="CMD" low="29" high="31" type="a6xx_tex_prefetch_cmd"/>
		</reg32>
	</array>
	<array offset="0xa99f" name="SP_PS_INITIAL_TEX_LOAD" stride="1" length="4" variants="A7XX-" usage="rp_blit">
		<reg32 offset="0" name="CMD" variants="A7XX-">
			<bitfield name="SRC" low="0" high="6" type="uint"/>
			<bitfield name="SAMP_ID" low="7" high="9" type="uint"/>
			<bitfield name="TEX_ID" low="10" high="12" type="uint"/>
			<bitfield name="DST" low="13" high="18" type="a3xx_regid"/>
			<bitfield name="WRMASK" low="19" high="22" type="hex"/>
			<bitfield name="HALF" pos="23" type="boolean"/>
			<bitfield name="BINDLESS" pos="25" type="boolean"/>
			<bitfield name="CMD" low="26" high="29" type="a6xx_tex_prefetch_cmd"/>
		</reg32>
	</array>
	<array offset="0xa9a3" name="SP_PS_INITIAL_TEX_INDEX" stride="1" length="4" usage="rp_blit">
		<reg32 offset="0" name="CMD">
			<bitfield name="SAMP_ID" low="0" high="15" type="uint"/>
			<bitfield name="TEX_ID" low="16" high="31" type="uint"/>
		</reg32>
	</array>
	<reg32 offset="0xa9a7" name="SP_PS_TSIZE" low="0" high="7" type="uint" usage="rp_blit"/>
	<reg32 offset="0xa9a8" name="SP_UNKNOWN_A9A8" low="0" high="16" usage="cmd"/> <!-- always 0x0 ? -->
	<reg32 offset="0xa9a9" name="SP_PS_PVT_MEM_STACK_OFFSET" type="a6xx_sp_xs_pvt_mem_stack_offset" usage="rp_blit"/>
	<reg32 offset="0xa9ab" name="SP_PS_UNKNOWN_A9AB" variants="A7XX-" usage="cmd"/>

	<!-- TODO: unknown bool register at 0xa9aa, likely same as 0xa8c0-0xa8c3 but for FS -->




	<reg32 offset="0xa9b0" name="SP_CS_CNTL_0" type="a6xx_sp_xs_cntl_0" usage="cmd">
		<bitfield name="THREADSIZE" pos="20" type="a6xx_threadsize"/>
		<!-- seems to make SP use less concurrent threads when possible? -->
		<bitfield name="UNK21" pos="21" type="boolean"/>
		<!-- has a small impact on performance, not clear what it does -->
		<bitfield name="UNK22" pos="22" type="boolean"/>
		<bitfield name="EARLYPREAMBLE" pos="23" type="boolean"/>
		<bitfield name="MERGEDREGS" pos="31" type="boolean"/>
	</reg32>

	<enum name="a6xx_const_ram_mode">
		<value value="0x0" name="CONSTLEN_128"/>
		<value value="0x1" name="CONSTLEN_192"/>
		<value value="0x2" name="CONSTLEN_256"/>
		<value value="0x3" name="CONSTLEN_512"/> <!-- a7xx only -->
	</enum>

	<!-- set for compute shaders -->
	<reg32 offset="0xa9b1" name="SP_CS_CNTL_1" usage="cmd">
		<bitfield name="SHARED_SIZE" low="0" high="4" type="uint">
			<doc>
				If 0 - all 32k of shared storage is enabled, otherwise
				(SHARED_SIZE + 1) * 1k is enabled.
				The ldl/stl offset seems to be rewritten to 0 when it is beyond
				this limit. This is different from ldlw/stlw, which wraps at
				64k (and has 36k of storage on A640 - reads between 36k-64k
				always return 0)
			</doc>
		</bitfield>
		<bitfield name="CONSTANTRAMMODE" low="5" high="6" type="a6xx_const_ram_mode">
			<doc>
				This defines the split between consts and local
				memory in the Local Buffer. The programmed value
				must be at least the actual CONSTLEN.
			</doc>
		</bitfield>
	</reg32>
	<reg32 offset="0xa9b2" name="SP_CS_BOOLEAN_CF_MASK" type="hex" usage="cmd"/>
	<reg32 offset="0xa9b3" name="SP_CS_PROGRAM_COUNTER_OFFSET" type="uint" usage="cmd"/>
	<reg64 offset="0xa9b4" name="SP_CS_BASE" type="address" align="32" usage="cmd"/>
	<reg32 offset="0xa9b6" name="SP_CS_PVT_MEM_PARAM" type="a6xx_sp_xs_pvt_mem_param" usage="cmd"/>
	<reg64 offset="0xa9b7" name="SP_CS_PVT_MEM_BASE" type="waddress" align="32" usage="cmd"/>
	<reg32 offset="0xa9b9" name="SP_CS_PVT_MEM_SIZE" type="a6xx_sp_xs_pvt_mem_size" usage="cmd"/>
	<reg32 offset="0xa9ba" name="SP_CS_TSIZE" low="0" high="7" type="uint" usage="cmd"/>
	<reg32 offset="0xa9bb" name="SP_CS_CONFIG" type="a6xx_sp_xs_config" usage="cmd"/>
	<reg32 offset="0xa9bc" name="SP_CS_INSTR_SIZE" low="0" high="27" type="uint" usage="cmd"/>
	<reg32 offset="0xa9bd" name="SP_CS_PVT_MEM_STACK_OFFSET" type="a6xx_sp_xs_pvt_mem_stack_offset" usage="cmd"/>
	<reg32 offset="0xa9be" name="SP_CS_UNKNOWN_A9BE" variants="A7XX-" usage="cmd"/>
	<reg32 offset="0xa9c5" name="SP_CS_VGS_CNTL" variants="A7XX-" usage="cmd"/>

	<!-- new in a6xx gen4, matches SP_CS_CONST_CONFIG_0 -->
	<reg32 offset="0xa9c2" name="SP_CS_WIE_CNTL_0" usage="cmd">
		<bitfield name="WGIDCONSTID" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="WGSIZECONSTID" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="WGOFFSETCONSTID" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="LOCALIDREGID" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<!-- new in a6xx gen4, matches SP_CS_WGE_CNTL -->
	<reg32 offset="0xa9c3" name="SP_CS_WIE_CNTL_1" variants="A6XX" usage="cmd">
		<!-- gl_LocalInvocationIndex -->
		<bitfield name="LINEARLOCALIDREGID" low="0" high="7" type="a3xx_regid"/>
		<!-- a650 has 6 "SP cores" (but 3 "SP"). this makes it use only
		     one of those 6 "SP cores" -->
		<bitfield name="SINGLE_SP_CORE" pos="8" type="boolean"/>
		<!-- Must match SP_CS_CTRL -->
		<bitfield name="THREADSIZE" pos="9" type="a6xx_threadsize"/>
		<!-- 1 thread per wave (ignored if bit9 set) -->
		<bitfield name="THREADSIZE_SCALAR" pos="10" type="boolean"/>
	</reg32>

	<enum name="a7xx_workitem_rast_order">
		<value value="0x0" name="WORKITEMRASTORDER_LINEAR"/>
		<doc>
			This is a fixed tiling, with 4x4 invocation outer tiles
			containing 2x2 invocation inner tiles. The intent is to
			improve cache locality with textures and images accessed
			using gl_LocalInvocationID.
		</doc>
		<value value="0x1" name="WORKITEMRASTORDER_TILED"/>
	</enum>

	<reg32 offset="0xa9c3" name="SP_CS_WIE_CNTL_1" variants="A7XX-" usage="cmd">
		<!-- gl_LocalInvocationIndex -->
		<bitfield name="LINEARLOCALIDREGID" low="0" high="7" type="a3xx_regid"/>
		<!-- Must match SP_CS_CTRL -->
		<bitfield name="THREADSIZE" pos="8" type="a6xx_threadsize"/>
		<!-- 1 thread per wave (would hang if THREAD128 is also set) -->
		<bitfield name="THREADSIZE_SCALAR" pos="9" type="boolean"/>

		<doc>How invocations/fibers within a workgroup are tiled.</doc>
		<bitfield name="WORKITEMRASTORDER" pos="15" type="a7xx_workitem_rast_order"/>
	</reg32>

	<!-- TODO: two 64kb aligned addresses at a9d0/a9d2 -->

	<reg64 offset="0xa9e0" name="SP_PS_SAMPLER_BASE" type="address" align="16" usage="rp_blit"/>
	<reg64 offset="0xa9e2" name="SP_CS_SAMPLER_BASE" type="address" align="16" usage="cmd"/>
	<reg64 offset="0xa9e4" name="SP_PS_TEXMEMOBJ_BASE" type="address" align="64" usage="rp_blit"/>
	<reg64 offset="0xa9e6" name="SP_CS_TEXMEMOBJ_BASE" type="address" align="64" usage="cmd"/>

	<enum name="a6xx_bindless_descriptor_size">
		<doc>
			This can alternatively be interpreted as a pitch shift, ie, the
			descriptor size is 2 &lt;&lt; N dwords
		</doc>
		<value value="1" name="BINDLESS_DESCRIPTOR_16B"/>
		<value value="3" name="BINDLESS_DESCRIPTOR_64B"/>
	</enum>

	<array offset="0xa9e8" name="SP_CS_BINDLESS_BASE" stride="2" length="5" variants="A6XX" usage="cmd">
		<reg64 offset="0" name="DESCRIPTOR" variants="A6XX">
			<bitfield name="DESC_SIZE" low="0" high="1" type="a6xx_bindless_descriptor_size"/>
			<bitfield name="ADDR" low="2" high="63" shr="2" type="address"/>
		</reg64>
	</array>
	<array offset="0xa9e8" name="SP_CS_BINDLESS_BASE" stride="2" length="8" variants="A7XX-" usage="cmd">
		<reg64 offset="0" name="DESCRIPTOR" variants="A7XX-">
			<bitfield name="DESC_SIZE" low="0" high="1" type="a6xx_bindless_descriptor_size"/>
			<bitfield name="ADDR" low="2" high="63" shr="2" type="address"/>
		</reg64>
	</array>

	<!--
	UAV state for compute shader:
	 -->
	<reg64 offset="0xa9f2" name="SP_CS_UAV_BASE" type="address" align="16" variants="A6XX"/>
	<reg64 offset="0xa9f8" name="SP_CS_UAV_BASE" type="address" align="16" variants="A7XX-"/>
	<reg32 offset="0xaa00" name="SP_CS_USIZE" low="0" high="6" type="uint"/>

	<!-- Correlated with avgs/uvgs usage in FS -->
	<reg32 offset="0xaa01" name="SP_PS_VGS_CNTL" type="uint" variants="A7XX-" usage="cmd"/>

	<reg32 offset="0xaa02" name="SP_PS_OUTPUT_CONST_CNTL" variants="A7XX-" usage="cmd">
		<bitfield name="ENABLED" pos="0" type="boolean"/>
	</reg32>
	<reg32 offset="0xaa03" name="SP_PS_OUTPUT_CONST_MASK" variants="A7XX-" usage="cmd">
		<doc>
			Specify for which components the output color should be read
			from alias, e.g. for:

				alias.1.b32.0 r3.x, c8.x
				alias.1.b32.0 r2.x, c4.x
				alias.1.b32.0 r1.x, c4.x
				alias.1.b32.0 r0.x, c0.x

			the SP_PS_OUTPUT_CONST_MASK would be 0x00001111
		</doc>

		<bitfield name="RT0" low="0" high="3"/>
		<bitfield name="RT1" low="4" high="7"/>
		<bitfield name="RT2" low="8" high="11"/>
		<bitfield name="RT3" low="12" high="15"/>
		<bitfield name="RT4" low="16" high="19"/>
		<bitfield name="RT5" low="20" high="23"/>
		<bitfield name="RT6" low="24" high="27"/>
		<bitfield name="RT7" low="28" high="31"/>
	</reg32>

	<reg32 offset="0xaaf2" name="SP_UNKNOWN_AAF2" type="uint" usage="cmd"/>

	<!--
                This enum is probably similar in purpose to SNORMMODE on a3xx,
                minus the snorm stuff, i.e. it controls what happens with an
                out-of-bounds isam/isamm. GL and Vulkan robustness require us to
                return 0 on out-of-bound textureFetch().
	-->
	<enum name="a6xx_isam_mode">
		<value value="0x1" name="ISAMMODE_CL"/>
		<value value="0x2" name="ISAMMODE_GL"/>
	</enum>

	<reg32 offset="0xab00" name="SP_MODE_CNTL" usage="rp_blit">
	  <!--
	  When set, half register loads from the constant file will
	  load a 32-bit value (so hc0.y loads the same value as c0.y)
	  and implicitly convert it to 16b (f2f16, or u2u16, based on
	  operand type).  When unset, half register loads from the
	  constant file will load 16 bits from the packed constant
	  file (so hc0.y loads the top 16 bits of the value of c0.x)
	  -->
		<bitfield name="CONSTANT_DEMOTION_ENABLE" pos="0" type="boolean"/>
		<bitfield name="ISAMMODE" low="1" high="2" type="a6xx_isam_mode"/>
		<bitfield name="SHARED_CONSTS_ENABLE" pos="3" type="boolean"/> <!-- see HLSQ_SHARED_CONSTS -->
	</reg32>

	<reg32 offset="0xab01" name="SP_UNKNOWN_AB01" variants="A7XX-" usage="cmd"/>
	<reg32 offset="0xab02" name="SP_UNKNOWN_AB02" variants="A7XX-" usage="cmd"/>

	<reg32 offset="0xab04" name="SP_PS_CONFIG" type="a6xx_sp_xs_config" usage="rp_blit"/>
	<reg32 offset="0xab05" name="SP_PS_INSTR_SIZE" low="0" high="27" type="uint" usage="rp_blit"/>

	<array offset="0xab10" name="SP_GFX_BINDLESS_BASE" stride="2" length="5" variants="A6XX" usage="rp_blit">
		<reg64 offset="0" name="DESCRIPTOR" variants="A6XX">
			<bitfield name="DESC_SIZE" low="0" high="1" type="a6xx_bindless_descriptor_size"/>
			<bitfield name="ADDR" low="2" high="63" shr="2" type="address"/>
		</reg64>
	</array>
	<array offset="0xab0a" name="SP_GFX_BINDLESS_BASE" stride="2" length="8" variants="A7XX-" usage="rp_blit">
		<reg64 offset="0" name="DESCRIPTOR" variants="A7XX-">
			<bitfield name="DESC_SIZE" low="0" high="1" type="a6xx_bindless_descriptor_size"/>
			<bitfield name="ADDR" low="2" high="63" shr="2" type="address"/>
		</reg64>
	</array>

	<!--
	Combined UAV state for 3d pipe, used for Image and SSBO write/atomic
	instructions VS/HS/DS/GS/FS.  See SP_CS_UAV_BASE_* for compute shaders.
	 -->
	<reg64 offset="0xab1a" name="SP_GFX_UAV_BASE" type="address" align="16" usage="cmd"/>
	<reg32 offset="0xab20" name="SP_GFX_USIZE" low="0" high="6" type="uint" variants="A6XX-A7XX" usage="cmd"/>

	<reg32 offset="0xab22" name="SP_UNKNOWN_AB22" variants="A7XX" usage="cmd"/>

	<enum name="a6xx_sp_a2d_output_ifmt_type">
		<value name="OUTPUT_IFMT_2D_FLOAT" value="0"/>
		<value name="OUTPUT_IFMT_2D_SINT" value="1"/>
		<value name="OUTPUT_IFMT_2D_UINT" value="2"/>
	</enum>

	<bitset name="a6xx_sp_a2d_output_info" inline="yes">
		<bitfield name="HALF_PRECISION" pos="0" type="boolean"/>
		<bitfield name="IFMT_TYPE" low="1" high="2" type="a6xx_sp_a2d_output_ifmt_type"/>
		<!-- looks like HW only cares about the base type of this format,
		     which matches the ifmt? -->
		<bitfield name="COLOR_FORMAT" low="3" high="10" type="a6xx_format"/>
		<!-- set when ifmt is R2D_UNORM8_SRGB -->
		<bitfield name="SRGB" pos="11" type="boolean"/>
		<!-- some sort of channel mask, not sure what it is for -->
		<bitfield name="MASK" low="12" high="15"/>
	</bitset>

	<reg32 offset="0xacc0" name="SP_A2D_OUTPUT_INFO" type="a6xx_sp_a2d_output_info" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xa9bf" name="SP_A2D_OUTPUT_INFO" type="a6xx_sp_a2d_output_info" variants="A7XX-" usage="rp_blit"/>

	<reg32 offset="0xae00" name="SP_DBG_ECO_CNTL" usage="cmd"/>
	<reg32 offset="0xae01" name="SP_ADDR_MODE_CNTL" pos="0" type="a5xx_address_mode"/>
	<reg32 offset="0xae02" name="SP_NC_MODE_CNTL">
		<!-- TODO: valid bits 0x3c3f, see kernel -->
	</reg32>
	<reg32 offset="0xae03" name="SP_CHICKEN_BITS" usage="cmd"/>
	<reg32 offset="0xae04" name="SP_NC_MODE_CNTL_2" usage="cmd">
		<bitfield name="F16_NO_INF" pos="3" type="boolean"/>
	</reg32>

	<reg32 offset="0xae06" name="SP_UNKNOWN_AE06" variants="A7XX-" usage="cmd"/>
	<reg32 offset="0xae08" name="SP_CHICKEN_BITS_1" variants="A7XX-" usage="cmd"/>
	<reg32 offset="0xae09" name="SP_CHICKEN_BITS_2" variants="A7XX-" usage="cmd"/>
	<reg32 offset="0xae0a" name="SP_CHICKEN_BITS_3" variants="A7XX-" usage="cmd"/>

	<reg32 offset="0xae0f" name="SP_PERFCTR_SHADER_MASK" usage="cmd">
		<!-- some perfcntrs are affected by a per-stage enable bit
		     (PERF_SP_ALU_WORKING_CYCLES for example)
		     TODO: verify position of HS/DS/GS bits -->
		<bitfield name="VS" pos="0" type="boolean"/>
		<bitfield name="HS" pos="1" type="boolean"/>
		<bitfield name="DS" pos="2" type="boolean"/>
		<bitfield name="GS" pos="3" type="boolean"/>
		<bitfield name="FS" pos="4" type="boolean"/>
		<bitfield name="CS" pos="5" type="boolean"/>
	</reg32>
	<array offset="0xae10" name="SP_PERFCTR_SP_SEL" stride="1" length="24"/>
	<array offset="0xae60" name="SP_PERFCTR_HLSQ_SEL" stride="1" length="6" variants="A7XX-"/>
	<reg32 offset="0xae6a" name="SP_UNKNOWN_AE6A" variants="A7XX-" usage="cmd"/>
	<reg32 offset="0xae6b" name="SP_UNKNOWN_AE6B" variants="A7XX-" usage="cmd"/>
	<reg32 offset="0xae6c" name="SP_HLSQ_DBG_ECO_CNTL" variants="A7XX-" usage="cmd"/>
	<reg32 offset="0xae6d" name="SP_READ_SEL" variants="A7XX-">
		<bitfield name="LOCATION" low="18" high="20" type="a7xx_state_location"/>
		<bitfield name="PIPE" low="16" high="17" type="a7xx_pipe"/>
		<bitfield name="STATETYPE" low="8" high="15" type="a7xx_statetype_id"/>
		<bitfield name="USPTP" low="4" high="7"/>
		<bitfield name="SPTP" low="0" high="3"/>
	</reg32>
	<reg32 offset="0xae71" name="SP_DBG_CNTL" variants="A7XX-"/>
	<reg32 offset="0xae73" name="SP_UNKNOWN_AE73" variants="A7XX-" usage="cmd"/>
	<array offset="0xae80" name="SP_PERFCTR_SP_SEL" stride="1" length="36" variants="A7XX-"/>
	<!-- TODO: there are 4 more percntr select registers (0xae28-0xae2b) -->
	<!-- TODO: there are a few unknown registers in the 0xae30-0xae52 range -->
	<reg32 offset="0xbe22" name="SP_CONTEXT_SWITCH_GFX_PREEMPTION_SAFE_MODE"/>

	<!--
	The downstream kernel calls the debug cluster of registers
	"a6xx_sp_ps_tp_cluster" but this actually specifies the border
	color base for compute shaders.
	-->
	<reg64 offset="0xb180" name="TPL1_CS_BORDER_COLOR_BASE" type="address" align="128" usage="cmd"/>
	<reg32 offset="0xb182" name="SP_UNKNOWN_B182" low="0" high="2" usage="cmd"/>
	<reg32 offset="0xb183" name="SP_UNKNOWN_B183" low="0" high="23" usage="cmd"/>

	<reg32 offset="0xb190" name="SP_UNKNOWN_B190"/>
	<reg32 offset="0xb191" name="SP_UNKNOWN_B191"/>

	<reg32 offset="0xb300" name="TPL1_RAS_MSAA_CNTL" usage="rp_blit">
		<bitfield name="SAMPLES" low="0" high="1" type="a3xx_msaa_samples"/>
		<bitfield name="UNK2" low="2" high="3"/>
	</reg32>
	<reg32 offset="0xb301" name="TPL1_DEST_MSAA_CNTL" usage="rp_blit">
		<bitfield name="SAMPLES" low="0" high="1" type="a3xx_msaa_samples"/>
		<bitfield name="MSAA_DISABLE" pos="2" type="boolean"/>
	</reg32>

	<!-- looks to work in the same way as a5xx: -->
	<reg64 offset="0xb302" name="TPL1_GFX_BORDER_COLOR_BASE" type="address" align="128" usage="cmd"/>
	<reg32 offset="0xb304" name="TPL1_MSAA_SAMPLE_POS_CNTL" type="a6xx_msaa_sample_pos_cntl" variants="A6XX-A7XX" usage="rp_blit"/>
	<reg32 offset="0xb305" name="TPL1_PROGRAMMABLE_MSAA_POS_0" type="a6xx_programmable_msaa_pos" usage="rp_blit"/>
	<reg32 offset="0xb306" name="TPL1_PROGRAMMABLE_MSAA_POS_1" type="a6xx_programmable_msaa_pos" usage="rp_blit"/>
	<reg32 offset="0xb307" name="TPL1_WINDOW_OFFSET" type="a6xx_reg_xy" usage="rp_blit"/>

	<enum name="a6xx_coord_round">
		<value value="0" name="COORD_TRUNCATE"/>
		<value value="1" name="COORD_ROUND_NEAREST_EVEN"/>
	</enum>

	<enum name="a6xx_nearest_mode">
		<value value="0" name="ROUND_CLAMP_TRUNCATE"/>
		<value value="1" name="CLAMP_ROUND_TRUNCATE"/>
	</enum>

	<reg32 offset="0xb309" name="TPL1_MODE_CNTL" usage="cmd">
		<bitfield name="ISAMMODE" low="0" high="1" type="a6xx_isam_mode"/>
		<bitfield name="TEXCOORDROUNDMODE" pos="2" type="a6xx_coord_round"/>
		<bitfield name="NEARESTMIPSNAP" pos="5" type="a6xx_nearest_mode"/>
		<bitfield name="DESTDATATYPEOVERRIDE" pos="7" type="boolean"/>
	</reg32>
	<reg32 offset="0xb310" name="SP_UNKNOWN_B310" variants="A7XX-" usage="cmd"/>

	<!--
	Equiv to corresponding RB_2D_SRC_* regs on a5xx.. which were either
	badly named or the functionality moved in a6xx.  But downstream kernel
	calls this "a6xx_sp_ps_tp_2d_cluster"
	 -->
	<reg32 offset="0xb4c0" name="TPL1_A2D_SRC_TEXTURE_INFO" type="a6xx_a2d_src_texture_info" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb4c1" name="TPL1_A2D_SRC_TEXTURE_SIZE" variants="A6XX" usage="rp_blit">
		<bitfield name="WIDTH" low="0" high="14" type="uint"/>
		<bitfield name="HEIGHT" low="15" high="29" type="uint"/>
	</reg32>
	<reg64 offset="0xb4c2" name="TPL1_A2D_SRC_TEXTURE_BASE" type="address" align="16" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb4c4" name="TPL1_A2D_SRC_TEXTURE_PITCH" variants="A6XX" usage="rp_blit">
		<bitfield name="UNK0" low="0" high="8"/>
		<bitfield name="PITCH" low="9" high="23" shr="6" type="uint"/>
	</reg32>

	<reg32 offset="0xb2c0" name="TPL1_A2D_SRC_TEXTURE_INFO" type="a6xx_a2d_src_texture_info" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xb2c1" name="TPL1_A2D_SRC_TEXTURE_SIZE" variants="A7XX-">
		<bitfield name="WIDTH" low="0" high="14" type="uint"/>
		<bitfield name="HEIGHT" low="15" high="29" type="uint"/>
	</reg32>
	<reg64 offset="0xb2c2" name="TPL1_A2D_SRC_TEXTURE_BASE" type="address" align="16" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xb2c4" name="TPL1_A2D_SRC_TEXTURE_PITCH" variants="A7XX-">
		<!--
		Bits from 3..9 must be zero unless 'TPL1_A2D_BLT_CNTL::TYPE'
		is A6XX_TEX_IMG_BUFFER, which allows for lower alignment.
		 -->
		<bitfield name="PITCH" low="3" high="23" type="uint"/>
	</reg32>

	<!-- planes for NV12, etc. (TODO: not tested) -->
	<reg64 offset="0xb4c5" name="TPL1_A2D_SRC_TEXTURE_BASE_1" type="address" align="16" variants="A6XX"/>
	<reg32 offset="0xb4c7" name="TPL1_A2D_SRC_TEXTURE_PITCH_1" low="0" high="11" shr="6" type="uint" variants="A6XX"/>
	<reg64 offset="0xb4c8" name="TPL1_A2D_SRC_TEXTURE_BASE_2" type="address" align="16" variants="A6XX"/>

	<reg64 offset="0xb2c5" name="TPL1_A2D_SRC_TEXTURE_BASE_1" type="address" align="16" variants="A7XX-"/>
	<reg32 offset="0xb2c7" name="TPL1_A2D_SRC_TEXTURE_PITCH_1" low="0" high="11" shr="6" type="uint" variants="A7XX-"/>
	<reg64 offset="0xb2c8" name="TPL1_A2D_SRC_TEXTURE_BASE_2" type="address" align="16" variants="A7XX-"/>

	<reg64 offset="0xb4ca" name="TPL1_A2D_SRC_TEXTURE_FLAG_BASE" type="address" align="16" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb4cc" name="TPL1_A2D_SRC_TEXTURE_FLAG_PITCH" low="0" high="7" shr="6" type="uint" variants="A6XX" usage="rp_blit"/>

	<reg64 offset="0xb2ca" name="TPL1_A2D_SRC_TEXTURE_FLAG_BASE" type="address" align="16" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xb2cc" name="TPL1_A2D_SRC_TEXTURE_FLAG_PITCH" low="0" high="7" shr="6" type="uint" variants="A7XX-" usage="rp_blit"/>

	<reg32 offset="0xb4cd" name="SP_PS_UNKNOWN_B4CD" low="6" high="31" variants="A6XX"/>
	<reg32 offset="0xb4ce" name="SP_PS_UNKNOWN_B4CE" low="0" high="31" variants="A6XX"/>
	<reg32 offset="0xb4cf" name="SP_PS_UNKNOWN_B4CF" low="0" high="30" variants="A6XX"/>
	<reg32 offset="0xb4d0" name="SP_PS_UNKNOWN_B4D0" low="0" high="29" variants="A6XX"/>
	<reg32 offset="0xb4d1" name="SP_WINDOW_OFFSET" type="a6xx_reg_xy" variants="A6XX" usage="rp_blit"/>

	<reg32 offset="0xb2cd" name="SP_PS_UNKNOWN_B4CD" low="6" high="31" variants="A7XX"/>
	<reg32 offset="0xb2ce" name="SP_PS_UNKNOWN_B4CE" low="0" high="31" variants="A7XX"/>
	<reg32 offset="0xb2cf" name="SP_PS_UNKNOWN_B4CF" low="0" high="30" variants="A7XX"/>
	<reg32 offset="0xb2d0" name="SP_PS_UNKNOWN_B4D0" low="0" high="29" variants="A7XX"/>
	<reg32 offset="0xb2d1" name="TPL1_A2D_WINDOW_OFFSET" type="a6xx_reg_xy" variants="A7XX-"/>
	<reg32 offset="0xb2d2" name="TPL1_A2D_BLT_CNTL" variants="A7XX-" usage="rp_blit">
		<bitfield name="RAW_COPY" pos="0" type="boolean"/>
		<bitfield name="START_OFFSET_TEXELS" low="16" high="21"/>
		<bitfield name="TYPE" low="29" high="31" type="a6xx_tex_type"/>
	</reg32>
	<reg32 offset="0xab21" name="SP_WINDOW_OFFSET" type="a6xx_reg_xy" variants="A7XX" usage="rp_blit"/>

	<!-- always 0x100000 or 0x1000000? -->
	<reg32 offset="0xb600" name="TPL1_DBG_ECO_CNTL" low="0" high="25" usage="cmd"/>
	<reg32 offset="0xb601" name="TPL1_ADDR_MODE_CNTL" type="a5xx_address_mode"/>
	<reg32 offset="0xb602" name="TPL1_DBG_ECO_CNTL1" usage="cmd">
		<!-- Affects UBWC in some way, if BLIT_OP_SCALE is done with this bit set
		     and if other blit is done without it - UBWC image may be copied incorrectly.
		 -->
		<bitfield name="TP_UBWC_FLAG_HINT" pos="18" type="boolean"/>
	</reg32>
	<reg32 offset="0xb604" name="TPL1_NC_MODE_CNTL">
		<bitfield name="MODE" pos="0" type="boolean"/>
		<bitfield name="LOWER_BIT" low="1" high="2" type="uint"/>
		<bitfield name="MIN_ACCESS_LENGTH" pos="3" type="boolean"/> <!-- true=64b false=32b -->
		<bitfield name="UPPER_BIT" pos="4" type="uint"/>
		<bitfield name="UNK6" low="6" high="7"/>
	</reg32>
	<reg32 offset="0xb605" name="TPL1_UNKNOWN_B605" low="0" high="7" type="uint" variants="A6XX" usage="cmd"/> <!-- always 0x0 or 0x44 ? -->

	<array offset="0xb608" name="TPL1_BICUBIC_WEIGHTS_TABLE" stride="1" length="5" variants="A6XX">
		<reg32 offset="0" name="REG" low="0" high="29"/>
	</array>

	<array offset="0xb608" name="TPL1_BICUBIC_WEIGHTS_TABLE" stride="1" length="5" variants="A7XX">
		<reg32 offset="0" name="REG" low="0" high="29" usage="cmd"/>
	</array>

	<array offset="0xb610" name="TPL1_PERFCTR_TP_SEL" stride="1" length="12" variants="A6XX"/>
	<array offset="0xb610" name="TPL1_PERFCTR_TP_SEL" stride="1" length="18" variants="A7XX"/>

	<!-- TODO: 4 more perfcntr sel at 0xb620 ? -->

	<bitset name="a6xx_xs_const_config" inline="yes">
		<bitfield name="CONSTLEN" low="0" high="7" shr="2" type="uint"/>
		<bitfield name="ENABLED" pos="8" type="boolean"/>
		<bitfield name="READ_IMM_SHARED_CONSTS" pos="9" type="boolean" variants="A7XX-"/>
	</bitset>

	<reg32 offset="0xb800" name="SP_VS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb801" name="SP_HS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb802" name="SP_DS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb803" name="SP_GS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A6XX" usage="rp_blit"/>

	<reg32 offset="0xa827" name="SP_VS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xa83f" name="SP_HS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xa867" name="SP_DS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xa898" name="SP_GS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A7XX-" usage="rp_blit"/>

	<reg32 offset="0xa9aa" name="SP_RENDER_CNTL" variants="A7XX-" usage="rp_blit">
		<bitfield name="FS_DISABLE" pos="0" type="boolean"/>
	</reg32>

	<reg32 offset="0xa9ac" name="SP_DITHER_CNTL" variants="A7XX-" usage="cmd">
		<bitfield name="DITHER_MODE_MRT0" low="0"  high="1"  type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT1" low="2"  high="3"  type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT2" low="4"  high="5"  type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT3" low="6"  high="7"  type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT4" low="8"  high="9"  type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT5" low="10" high="11" type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT6" low="12" high="13" type="adreno_rb_dither_mode"/>
		<bitfield name="DITHER_MODE_MRT7" low="14" high="15" type="adreno_rb_dither_mode"/>
	</reg32>

	<reg32 offset="0xa9ad" name="SP_VRS_CONFIG" variants="A7XX-" usage="rp_blit">
		<bitfield name="PIPELINE_FSR_ENABLE" pos="0" type="boolean"/>
		<bitfield name="ATTACHMENT_FSR_ENABLE" pos="1" type="boolean"/>
		<bitfield name="PRIMITIVE_FSR_ENABLE" pos="3" type="boolean"/>
	</reg32>

	<reg32 offset="0xa9ae" name="SP_PS_CNTL_1" variants="A7XX-" usage="rp_blit">
		<bitfield name="SYSVAL_REGS_COUNT" low="0" high="7" type="uint"/>
		<!-- UNK8 is set on a730/a740 -->
		<bitfield name="UNK8" pos="8" type="boolean"/>
		<!-- UNK9 is set on a750 -->
		<bitfield name="UNK9" pos="9" type="boolean"/>
	</reg32>

	<reg32 offset="0xb820" name="HLSQ_LOAD_STATE_GEOM_CMD"/>
	<reg64 offset="0xb821" name="HLSQ_LOAD_STATE_GEOM_EXT_SRC_ADDR" align="16" type="address"/>
	<reg32 offset="0xb823" name="HLSQ_LOAD_STATE_GEOM_DATA"/>


	<bitset name="a6xx_sp_ps_wave_cntl" inline="yes">
		<!-- must match SP_FS_CTRL -->
		<bitfield name="THREADSIZE" pos="0" type="a6xx_threadsize"/>
		<bitfield name="VARYINGS" pos="1" type="boolean"/>
		<bitfield name="UNK2" low="2" high="11"/>
	</bitset>
	<bitset name="a6xx_sp_reg_prog_id_1" inline="yes">
		<!-- register loaded with position (bary.f) -->
		<bitfield name="IJ_PERSP_PIXEL" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="IJ_LINEAR_PIXEL" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="IJ_PERSP_CENTROID" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="IJ_LINEAR_CENTROID" low="24" high="31" type="a3xx_regid"/>
	</bitset>
	<bitset name="a6xx_sp_reg_prog_id_2" inline="yes">
		<bitfield name="IJ_PERSP_SAMPLE" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="IJ_LINEAR_SAMPLE" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="XYCOORDREGID" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="ZWCOORDREGID" low="24" high="31" type="a3xx_regid"/>
	</bitset>
	<bitset name="a6xx_sp_reg_prog_id_3" inline="yes">
		<bitfield name="LINELENGTHREGID" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="FOVEATIONQUALITYREGID" low="8" high="15" type="a3xx_regid"/>
	</bitset>

	<reg32 offset="0xb980" type="a6xx_sp_ps_wave_cntl" name="SP_PS_WAVE_CNTL" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb981" name="HLSQ_UNKNOWN_B981" pos="0" type="boolean" variants="A6XX"/> <!-- never used by blob -->
	<reg32 offset="0xb982" name="SP_LB_PARAM_LIMIT" low="0" high="2" variants="A6XX" usage="rp_blit">
		<!-- Sets the maximum number of primitives allowed in one FS wave minus one, similarly to the
				 A3xx field, except that it's not necessary to set it to anything but the maximum, since
				 the hardware will simply emit smaller waves when it runs out of space.	-->
		<bitfield name="PRIMALLOCTHRESHOLD" low="0" high="2" type="uint"/>
	</reg32>
	<reg32 offset="0xb983" name="SP_REG_PROG_ID_0" variants="A6XX" usage="rp_blit">
		<bitfield name="FACEREGID" low="0" high="7" type="a3xx_regid"/>
		<!-- SAMPLEID is loaded into a half-precision register: -->
		<bitfield name="SAMPLEID" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="SAMPLEMASK" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="CENTERRHW" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0xb984" type="a6xx_sp_reg_prog_id_1" name="SP_REG_PROG_ID_1" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb985" type="a6xx_sp_reg_prog_id_2" name="SP_REG_PROG_ID_2" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb986" type="a6xx_sp_reg_prog_id_3" name="SP_REG_PROG_ID_3" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb987" name="SP_CS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A6XX" usage="cmd"/>
	<reg32 offset="0xa9c6" type="a6xx_sp_ps_wave_cntl" name="SP_PS_WAVE_CNTL" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xa9c7" name="SP_LB_PARAM_LIMIT" low="0" high="2" variants="A7XX-" usage="rp_blit">
			<bitfield name="PRIMALLOCTHRESHOLD" low="0" high="2" type="uint"/>
	</reg32>
	<reg32 offset="0xa9c8" name="SP_REG_PROG_ID_0" variants="A7XX-" usage="rp_blit">
		<bitfield name="FACEREGID" low="0" high="7" type="a3xx_regid"/>
		<!-- SAMPLEID is loaded into a half-precision register: -->
		<bitfield name="SAMPLEID" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="SAMPLEMASK" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="CENTERRHW" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0xa9c9" type="a6xx_sp_reg_prog_id_1" name="SP_REG_PROG_ID_1" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xa9ca" type="a6xx_sp_reg_prog_id_2" name="SP_REG_PROG_ID_2" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xa9cb" type="a6xx_sp_reg_prog_id_3" name="SP_REG_PROG_ID_3" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xa9cd" name="SP_CS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A7XX-" usage="cmd"/>

	<!-- TODO: what does KERNELDIM do exactly (blob sets it differently from turnip) -->
	<reg32 offset="0xb990" name="SP_CS_NDRANGE_0" variants="A6XX" usage="rp_blit">
		<bitfield name="KERNELDIM" low="0" high="1" type="uint"/>
		<!-- localsize is value minus one: -->
		<bitfield name="LOCALSIZEX" low="2" high="11" type="uint"/>
		<bitfield name="LOCALSIZEY" low="12" high="21" type="uint"/>
		<bitfield name="LOCALSIZEZ" low="22" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xb991" name="SP_CS_NDRANGE_1" variants="A6XX" usage="rp_blit">
		<bitfield name="GLOBALSIZE_X" low="0" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xb992" name="SP_CS_NDRANGE_2" variants="A6XX" usage="rp_blit">
		<bitfield name="GLOBALOFF_X" low="0" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xb993" name="SP_CS_NDRANGE_3" variants="A6XX" usage="rp_blit">
		<bitfield name="GLOBALSIZE_Y" low="0" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xb994" name="SP_CS_NDRANGE_4" variants="A6XX" usage="rp_blit">
		<bitfield name="GLOBALOFF_Y" low="0" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xb995" name="SP_CS_NDRANGE_5" variants="A6XX" usage="rp_blit">
		<bitfield name="GLOBALSIZE_Z" low="0" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xb996" name="SP_CS_NDRANGE_6" variants="A6XX" usage="rp_blit">
		<bitfield name="GLOBALOFF_Z" low="0" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xb997" name="SP_CS_CONST_CONFIG_0" variants="A6XX" usage="rp_blit">
		<!-- these are all vec3. first 3 need to be high regs
		     WGSIZECONSTID is the local size (from SP_CS_NDRANGE_0)
		     WGOFFSETCONSTID is WGIDCONSTID*WGSIZECONSTID
		-->
		<bitfield name="WGIDCONSTID" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="WGSIZECONSTID" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="WGOFFSETCONSTID" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="LOCALIDREGID" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0xb998" name="SP_CS_WGE_CNTL" variants="A6XX" usage="rp_blit">
		<!-- gl_LocalInvocationIndex -->
		<bitfield name="LINEARLOCALIDREGID" low="0" high="7" type="a3xx_regid"/>
		<!-- a650 has 6 "SP cores" (but 3 "SP"). this makes it use only
		     one of those 6 "SP cores" -->
		<bitfield name="SINGLE_SP_CORE" pos="8" type="boolean"/>
		<!-- Must match SP_CS_CTRL -->
		<bitfield name="THREADSIZE" pos="9" type="a6xx_threadsize"/>
		<!-- 1 thread per wave (ignored if bit9 set) -->
		<bitfield name="THREADSIZE_SCALAR" pos="10" type="boolean"/>
	</reg32>
	<!--note: vulkan blob doesn't use these -->
	<reg32 offset="0xb999" name="SP_CS_KERNEL_GROUP_X" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb99a" name="SP_CS_KERNEL_GROUP_Y" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xb99b" name="SP_CS_KERNEL_GROUP_Z" variants="A6XX" usage="rp_blit"/>

	<!-- TODO: what does KERNELDIM do exactly (blob sets it differently from turnip) -->
	<reg32 offset="0xa9d4" name="SP_CS_NDRANGE_0" variants="A7XX-" usage="rp_blit">
		<bitfield name="KERNELDIM" low="0" high="1" type="uint"/>
		<!-- localsize is value minus one: -->
		<bitfield name="LOCALSIZEX" low="2" high="11" type="uint"/>
		<bitfield name="LOCALSIZEY" low="12" high="21" type="uint"/>
		<bitfield name="LOCALSIZEZ" low="22" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xa9d5" name="SP_CS_NDRANGE_1" variants="A7XX-" usage="rp_blit">
		<bitfield name="GLOBALSIZE_X" low="0" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xa9d6" name="SP_CS_NDRANGE_2" variants="A7XX-" usage="rp_blit">
		<bitfield name="GLOBALOFF_X" low="0" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xa9d7" name="SP_CS_NDRANGE_3" variants="A7XX-" usage="rp_blit">
		<bitfield name="GLOBALSIZE_Y" low="0" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xa9d8" name="SP_CS_NDRANGE_4" variants="A7XX-" usage="rp_blit">
		<bitfield name="GLOBALOFF_Y" low="0" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xa9d9" name="SP_CS_NDRANGE_5" variants="A7XX-" usage="rp_blit">
		<bitfield name="GLOBALSIZE_Z" low="0" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0xa9da" name="SP_CS_NDRANGE_6" variants="A7XX-" usage="rp_blit">
		<bitfield name="GLOBALOFF_Z" low="0" high="31" type="uint"/>
	</reg32>
	<!--note: vulkan blob doesn't use these -->
	<reg32 offset="0xa9dc" name="SP_CS_KERNEL_GROUP_X" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xa9dd" name="SP_CS_KERNEL_GROUP_Y" variants="A7XX-" usage="rp_blit"/>
	<reg32 offset="0xa9de" name="SP_CS_KERNEL_GROUP_Z" variants="A7XX-" usage="rp_blit"/>

	<enum name="a7xx_cs_yalign">
		<value name="CS_YALIGN_1" value="8"/>
		<value name="CS_YALIGN_2" value="4"/>
		<value name="CS_YALIGN_4" value="2"/>
		<value name="CS_YALIGN_8" value="1"/>
	</enum>

	<reg32 offset="0xa9db" name="SP_CS_WGE_CNTL" variants="A7XX-" usage="rp_blit">
		<!-- gl_LocalInvocationIndex -->
		<bitfield name="LINEARLOCALIDREGID" low="0" high="7" type="a3xx_regid"/>
		<!-- Must match SP_CS_CTRL -->
		<bitfield name="THREADSIZE" pos="9" type="a6xx_threadsize"/>
		<doc>
			When this bit is enabled, the dispatch order interleaves
			the z coordinate instead of launching all workgroups
			with z=0, then all with z=1 and so on.
		</doc>
		<bitfield name="WORKGROUPRASTORDERZFIRSTEN" pos="11" type="boolean"/>
		<doc>
			When both fields are non-0 then the dispatcher uses
			these tile sizes to launch workgroups in a tiled manner
			when the x and y workgroup counts are
			both more than 1.
		</doc>
		<bitfield name="WGTILEWIDTH" low="20" high="25"/>
		<bitfield name="WGTILEHEIGHT" low="26" high="31"/>
	</reg32>

	<reg32 offset="0xa9df" name="SP_CS_NDRANGE_7" variants="A7XX-" usage="cmd">
		<!-- The size of the last workgroup. localsize is value minus one: -->
		<bitfield name="LOCALSIZEX" low="2" high="11" type="uint"/>
		<bitfield name="LOCALSIZEY" low="12" high="21" type="uint"/>
		<bitfield name="LOCALSIZEZ" low="22" high="31" type="uint"/>
	</reg32>

	<reg32 offset="0xb9a0" name="HLSQ_LOAD_STATE_FRAG_CMD"/>
	<reg64 offset="0xb9a1" name="HLSQ_LOAD_STATE_FRAG_EXT_SRC_ADDR" align="16" type="address"/>
	<reg32 offset="0xb9a3" name="HLSQ_LOAD_STATE_FRAG_DATA"/>

	<!-- mirror of SP_CS_BINDLESS_BASE -->
	<array offset="0xb9c0" name="HLSQ_CS_BINDLESS_BASE" stride="2" length="5" variants="A6XX" usage="rp_blit">
		<reg64 offset="0" name="DESCRIPTOR">
			<bitfield name="DESC_SIZE" low="0" high="1" type="a6xx_bindless_descriptor_size"/>
			<bitfield name="ADDR" low="2" high="63" shr="2" type="address"/>
		</reg64>
	</array>

	<!-- new in a6xx gen4, mirror of SP_CS_CNTL_1? -->
	<reg32 offset="0xb9d0" name="HLSQ_CS_CTRL_REG1" variants="A6XX" usage="cmd">
		<bitfield name="SHARED_SIZE" low="0" high="4" type="uint"/>
		<bitfield name="CONSTANTRAMMODE" low="5" high="6" type="a6xx_const_ram_mode"/>
	</reg32>

	<reg32 offset="0xbb00" name="SP_DRAW_INITIATOR" variants="A6XX">
		<bitfield name="STATE_ID" low="0" high="7"/>
	</reg32>

	<reg32 offset="0xbb01" name="SP_KERNEL_INITIATOR" variants="A6XX">
		<bitfield name="STATE_ID" low="0" high="7"/>
	</reg32>

	<reg32 offset="0xbb02" name="SP_EVENT_INITIATOR" variants="A6XX">
		<!-- I think only the low bit is actually used? -->
		<bitfield name="STATE_ID" low="16" high="23"/>
		<bitfield name="EVENT" low="0" high="6" type="vgt_event_type"/>
	</reg32>

	<reg32 offset="0xbb08" name="SP_UPDATE_CNTL" variants="A6XX" usage="cmd">
		<doc>
			This register clears pending loads queued up by
			CP_LOAD_STATE6. Each bit resets a particular kind(s) of
			CP_LOAD_STATE6.
		</doc>

		<!-- per-stage state: shader, non-bindless UBO, textures, and samplers -->
		<bitfield name="VS_STATE" pos="0" type="boolean"/>
		<bitfield name="HS_STATE" pos="1" type="boolean"/>
		<bitfield name="DS_STATE" pos="2" type="boolean"/>
		<bitfield name="GS_STATE" pos="3" type="boolean"/>
		<bitfield name="FS_STATE" pos="4" type="boolean"/>
		<bitfield name="CS_STATE" pos="5" type="boolean"/>

		<bitfield name="CS_UAV" pos="6" type="boolean"/>
		<bitfield name="GFX_UAV" pos="7" type="boolean"/>

		<!-- Note: these only do something when HLSQ_SHARED_CONSTS is set to 1 -->
		<bitfield name="CS_SHARED_CONST" pos="19" type="boolean"/>
		<bitfield name="GFX_SHARED_CONST" pos="8" type="boolean"/>

		<!-- SS6_BINDLESS: one bit per bindless base -->
		<bitfield name="CS_BINDLESS" low="9" high="13" type="hex"/>
		<bitfield name="GFX_BINDLESS" low="14" high="18" type="hex"/>
	</reg32>

	<reg32 offset="0xab1c" name="SP_DRAW_INITIATOR" variants="A7XX-">
		<bitfield name="STATE_ID" low="0" high="7"/>
	</reg32>

	<reg32 offset="0xab1d" name="SP_KERNEL_INITIATOR" variants="A7XX-">
		<bitfield name="STATE_ID" low="0" high="7"/>
	</reg32>

	<reg32 offset="0xab1e" name="SP_EVENT_INITIATOR" variants="A7XX-">
		<bitfield name="STATE_ID" low="16" high="23"/>
		<bitfield name="EVENT" low="0" high="6" type="vgt_event_type"/>
	</reg32>

	<reg32 offset="0xab1f" name="SP_UPDATE_CNTL" variants="A7XX-" usage="cmd">
		<doc>
			This register clears pending loads queued up by
			CP_LOAD_STATE6. Each bit resets a particular kind(s) of
			CP_LOAD_STATE6.
		</doc>

		<!-- per-stage state: shader, non-bindless UBO, textures, and samplers -->
		<bitfield name="VS_STATE" pos="0" type="boolean"/>
		<bitfield name="HS_STATE" pos="1" type="boolean"/>
		<bitfield name="DS_STATE" pos="2" type="boolean"/>
		<bitfield name="GS_STATE" pos="3" type="boolean"/>
		<bitfield name="FS_STATE" pos="4" type="boolean"/>
		<bitfield name="CS_STATE" pos="5" type="boolean"/>

		<bitfield name="CS_UAV" pos="6" type="boolean"/>
		<bitfield name="GFX_UAV" pos="7" type="boolean"/>

		<!-- SS6_BINDLESS: one bit per bindless base -->
		<bitfield name="CS_BINDLESS" low="9" high="16" type="hex"/>
		<bitfield name="GFX_BINDLESS" low="17" high="24" type="hex"/>
	</reg32>

	<reg32 offset="0xbb10" name="SP_PS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A6XX" usage="rp_blit"/>
	<reg32 offset="0xab03" name="SP_PS_CONST_CONFIG" type="a6xx_xs_const_config" variants="A7XX-" usage="rp_blit"/>

	<array offset="0xab40" name="SP_SHARED_CONSTANT_GFX" stride="1" length="64" variants="A7XX"/>

	<reg32 offset="0xbb11" name="HLSQ_SHARED_CONSTS" variants="A6XX" usage="cmd">
		<doc>
			Shared constants are intended to be used for Vulkan push
			constants. When enabled, 8 vec4's are reserved in the FS
			const pool and 16 in the geometry const pool although
			only 8 are actually used (why?) and they are mapped to
			c504-c511 in each stage. Both VS and FS shared consts
			are written using ST6_CONSTANTS/SB6_UAV, so that both
			the geometry and FS shared consts can be written at once
			by using CP_LOAD_STATE6 rather than
			CP_LOAD_STATE6_FRAG/CP_LOAD_STATE6_GEOM. In addition
			DST_OFF and NUM_UNIT are in units of dwords instead of
			vec4's.

			There is also a separate shared constant pool for CS,
			which is loaded through CP_LOAD_STATE6_FRAG with
			ST6_UBO/ST6_UAV. However the only real difference for CS
			is the dword units.
		</doc>
		<bitfield name="ENABLE" pos="0" type="boolean"/>
	</reg32>

	<!-- mirror of SP_GFX_BINDLESS_BASE -->
	<array offset="0xbb20" name="HLSQ_BINDLESS_BASE" stride="2" length="5" variants="A6XX" usage="cmd">
		<reg64 offset="0" name="DESCRIPTOR">
			<bitfield name="DESC_SIZE" low="0" high="1" type="a6xx_bindless_descriptor_size"/>
			<bitfield name="ADDR" low="2" high="63" shr="2" type="address"/>
		</reg64>
	</array>

	<reg32 offset="0xbd80" name="HLSQ_2D_EVENT_CMD">
		<bitfield name="STATE_ID" low="8" high="15"/>
		<bitfield name="EVENT" low="0" high="6" type="vgt_event_type"/>
	</reg32>

	<reg32 offset="0xbe00" name="HLSQ_UNKNOWN_BE00" variants="A6XX" usage="cmd"/> <!-- all bits valid except bit 29 -->
	<reg32 offset="0xbe01" name="HLSQ_UNKNOWN_BE01" low="4" high="6" variants="A6XX" usage="cmd"/>
	<reg32 offset="0xbe04" name="HLSQ_DBG_ECO_CNTL" variants="A6XX" usage="cmd"/>
	<reg32 offset="0xbe05" name="HLSQ_ADDR_MODE_CNTL" type="a5xx_address_mode"/>
	<reg32 offset="0xbe08" name="HLSQ_UNKNOWN_BE08" low="0" high="15"/>
	<array offset="0xbe10" name="HLSQ_PERFCTR_HLSQ_SEL" stride="1" length="6"/>

	<!-- TODO: some valid registers between 0xbe20 and 0xbe33 -->
	<reg32 offset="0xbe22" name="HLSQ_CONTEXT_SWITCH_GFX_PREEMPTION_SAFE_MODE"/>

	<reg32 offset="0xc000" name="SP_AHB_READ_APERTURE" variants="A7XX-"/>

	<!-- Don't know if these are SP, always 0 -->
	<reg64 offset="0x0ce2" name="SP_UNKNOWN_0CE2" variants="A7XX-" usage="cmd"/>
	<reg64 offset="0x0ce4" name="SP_UNKNOWN_0CE4" variants="A7XX-" usage="cmd"/>
	<reg64 offset="0x0ce6" name="SP_UNKNOWN_0CE6" variants="A7XX-" usage="cmd"/>

	<!--
		These special registers signal the beginning/end of an event
		sequence. The sequence used internally for an event looks like:
		- write EVENT_CMD pipe register
		- write CP_EVENT_START
		- write SP_EVENT_INITIATOR with event or SP_DRAW_INITIATOR
		- write PC_EVENT_INITIATOR with event or PC_DRAW_INITIATOR
		- write SP_EVENT_INITIATOR(CONTEXT_DONE)
		- write PC_EVENT_INITIATOR(CONTEXT_DONE)
		- write CP_EVENT_END
		Writing to CP_EVENT_END seems to actually trigger the context roll
	-->
	<reg32 offset="0xd600" name="CP_EVENT_START">
		<bitfield name="STATE_ID" low="0" high="7"/>
	</reg32>
	<reg32 offset="0xd601" name="CP_EVENT_END">
		<bitfield name="STATE_ID" low="0" high="7"/>
	</reg32>
	<reg32 offset="0xd700" name="CP_2D_EVENT_START">
		<bitfield name="STATE_ID" low="0" high="7"/>
	</reg32>
	<reg32 offset="0xd701" name="CP_2D_EVENT_END">
		<bitfield name="STATE_ID" low="0" high="7"/>
	</reg32>
</domain>

<domain name="A6XX_PDC" width="32">
	<reg32 offset="0x1140" name="GPU_ENABLE_PDC"/>
	<reg32 offset="0x1148" name="GPU_SEQ_START_ADDR"/>
	<reg32 offset="0x1540" name="GPU_TCS0_CONTROL"/>
	<reg32 offset="0x1541" name="GPU_TCS0_CMD_ENABLE_BANK"/>
	<reg32 offset="0x1542" name="GPU_TCS0_CMD_WAIT_FOR_CMPL_BANK"/>
	<reg32 offset="0x1543" name="GPU_TCS0_CMD0_MSGID"/>
	<reg32 offset="0x1544" name="GPU_TCS0_CMD0_ADDR"/>
	<reg32 offset="0x1545" name="GPU_TCS0_CMD0_DATA"/>
	<reg32 offset="0x1572" name="GPU_TCS1_CONTROL"/>
	<reg32 offset="0x1573" name="GPU_TCS1_CMD_ENABLE_BANK"/>
	<reg32 offset="0x1574" name="GPU_TCS1_CMD_WAIT_FOR_CMPL_BANK"/>
	<reg32 offset="0x1575" name="GPU_TCS1_CMD0_MSGID"/>
	<reg32 offset="0x1576" name="GPU_TCS1_CMD0_ADDR"/>
	<reg32 offset="0x1577" name="GPU_TCS1_CMD0_DATA"/>
	<reg32 offset="0x15A4" name="GPU_TCS2_CONTROL"/>
	<reg32 offset="0x15A5" name="GPU_TCS2_CMD_ENABLE_BANK"/>
	<reg32 offset="0x15A6" name="GPU_TCS2_CMD_WAIT_FOR_CMPL_BANK"/>
	<reg32 offset="0x15A7" name="GPU_TCS2_CMD0_MSGID"/>
	<reg32 offset="0x15A8" name="GPU_TCS2_CMD0_ADDR"/>
	<reg32 offset="0x15A9" name="GPU_TCS2_CMD0_DATA"/>
	<reg32 offset="0x15D6" name="GPU_TCS3_CONTROL"/>
	<reg32 offset="0x15D7" name="GPU_TCS3_CMD_ENABLE_BANK"/>
	<reg32 offset="0x15D8" name="GPU_TCS3_CMD_WAIT_FOR_CMPL_BANK"/>
	<reg32 offset="0x15D9" name="GPU_TCS3_CMD0_MSGID"/>
	<reg32 offset="0x15DA" name="GPU_TCS3_CMD0_ADDR"/>
	<reg32 offset="0x15DB" name="GPU_TCS3_CMD0_DATA"/>
</domain>

<domain name="A6XX_PDC_GPU_SEQ" width="32">
	<reg32 offset="0x0" name="MEM_0"/>
</domain>

<domain name="A6XX_CX_DBGC" width="32">
	<reg32 offset="0x0000" name="CFG_DBGBUS_SEL_A">
		<bitfield high="7" low="0" name="PING_INDEX"/>
		<bitfield high="15" low="8" name="PING_BLK_SEL"/>
	</reg32>
	<reg32 offset="0x0001" name="CFG_DBGBUS_SEL_B"/>
	<reg32 offset="0x0002" name="CFG_DBGBUS_SEL_C"/>
	<reg32 offset="0x0003" name="CFG_DBGBUS_SEL_D"/>
	<reg32 offset="0x0004" name="CFG_DBGBUS_CNTLT">
		<bitfield high="5" low="0" name="TRACEEN"/>
		<bitfield high="14" low="12" name="GRANU"/>
		<bitfield high="31" low="28" name="SEGT"/>
	</reg32>
	<reg32 offset="0x0005" name="CFG_DBGBUS_CNTLM">
		<bitfield high="27" low="24" name="ENABLE"/>
	</reg32>
	<reg32 offset="0x0008" name="CFG_DBGBUS_IVTL_0"/>
	<reg32 offset="0x0009" name="CFG_DBGBUS_IVTL_1"/>
	<reg32 offset="0x000a" name="CFG_DBGBUS_IVTL_2"/>
	<reg32 offset="0x000b" name="CFG_DBGBUS_IVTL_3"/>
	<reg32 offset="0x000c" name="CFG_DBGBUS_MASKL_0"/>
	<reg32 offset="0x000d" name="CFG_DBGBUS_MASKL_1"/>
	<reg32 offset="0x000e" name="CFG_DBGBUS_MASKL_2"/>
	<reg32 offset="0x000f" name="CFG_DBGBUS_MASKL_3"/>
	<reg32 offset="0x0010" name="CFG_DBGBUS_BYTEL_0">
		<bitfield high="3" low="0" name="BYTEL0"/>
		<bitfield high="7" low="4" name="BYTEL1"/>
		<bitfield high="11" low="8" name="BYTEL2"/>
		<bitfield high="15" low="12" name="BYTEL3"/>
		<bitfield high="19" low="16" name="BYTEL4"/>
		<bitfield high="23" low="20" name="BYTEL5"/>
		<bitfield high="27" low="24" name="BYTEL6"/>
		<bitfield high="31" low="28" name="BYTEL7"/>
	</reg32>
	<reg32 offset="0x0011" name="CFG_DBGBUS_BYTEL_1">
		<bitfield high="3" low="0" name="BYTEL8"/>
		<bitfield high="7" low="4" name="BYTEL9"/>
		<bitfield high="11" low="8" name="BYTEL10"/>
		<bitfield high="15" low="12" name="BYTEL11"/>
		<bitfield high="19" low="16" name="BYTEL12"/>
		<bitfield high="23" low="20" name="BYTEL13"/>
		<bitfield high="27" low="24" name="BYTEL14"/>
		<bitfield high="31" low="28" name="BYTEL15"/>
	</reg32>

	<reg32 offset="0x002f" name="CFG_DBGBUS_TRACE_BUF1"/>
	<reg32 offset="0x0030" name="CFG_DBGBUS_TRACE_BUF2"/>
</domain>

<domain name="A7XX_CX_DBGC" width="32" varset="chip">
	<!-- Bitfields shifted, but otherwise the same: -->
	<reg32 offset="0x0000" name="CFG_DBGBUS_SEL_A" variants="A7XX-">
		<bitfield high="7" low="0" name="PING_INDEX"/>
		<bitfield high="24" low="16" name="PING_BLK_SEL"/>
	</reg32>
</domain>

<domain name="A6XX_CX_MISC" width="32" prefix="variant" varset="chip">
	<reg32 offset="0x0001" name="SYSTEM_CACHE_CNTL_0"/>
	<reg32 offset="0x0002" name="SYSTEM_CACHE_CNTL_1"/>
	<reg32 offset="0x0039" name="CX_MISC_TCM_RET_CNTL" variants="A7XX-"/>
	<reg32 offset="0x0400" name="CX_MISC_SW_FUSE_VALUE" variants="A7XX-">
		<bitfield pos="0" name="FASTBLEND" type="boolean"/>
		<bitfield pos="1" name="LPAC" type="boolean"/>
		<bitfield pos="2" name="RAYTRACING" type="boolean"/>
	</reg32>
</domain>

</database>
